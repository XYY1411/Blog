<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/16107/</url>
    <content><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>新博客做好了，还在添加更多功能。</p>
]]></content>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/61809/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>并查集</strong>（英语：<strong>Disjoint-set data structure</strong>、<strong>disjoint-set data structure</strong> 或 <strong>merge–find set</strong>），是一种用于快速查询处理一些元素与集合的查询与合并的数据结构。</p>
<p>支持以下几种操作：</p>
<ul>
<li>查询：查询某个元素属于哪个集合。</li>
<li>合并：合并两个集合。</li>
<li>添加：添加一个元素作为一个新集合的元素。</li>
</ul>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>不加任何优化的并查集单次查询时间复杂度为 $O(n)$，经过路径压缩或按秩合并任意一种优化后的单次查询时间复杂度为 $O(\log n)$，如果同时使用两种优化时间复杂度则为 $O(\alpha(n))$。</p>
<p>空间复杂度为 $O(n)$。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>提供 C++ 编写，同时使用路径压缩和按秩合并优化的版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @file disjoint-set-data-structure.cpp</span><br><span class="hljs-comment">* @breif Disjoint-set data structure.</span><br><span class="hljs-comment">* @author XYY1411</span><br><span class="hljs-comment">* @email xyy1411@gmail.com</span><br><span class="hljs-comment">* @date 2021-12-11</span><br><span class="hljs-comment">* @license CC BY-NC-SA 4.0</span><br><span class="hljs-comment">* Compile instruction: g++ Luogu3367.cpp -o Luogu3367 -std=c++14 -Wall</span><br><span class="hljs-comment">*   -Wextra -fsanitize=address,undefined,bounds-strict -O2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">qread</span><span class="hljs-params">(T &amp;n)</span> </span>&#123;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27;-&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) flag = <span class="hljs-literal">true</span>, c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) n = (n &lt;&lt; <span class="hljs-number">3</span>) + (n &lt;&lt; <span class="hljs-number">1</span>) + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();<br>    n = flag ? -n : n;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Argv&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qread</span><span class="hljs-params">(T &amp;n, Argv &amp;...argv)</span> </span>&#123;<br>    <span class="hljs-built_in">qread</span>(n), <span class="hljs-built_in">qread</span>(argv...);<br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> fa[maxn], size[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) fa[i] = i, size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (size[fx] &lt; size[fy]) <span class="hljs-built_in">swap</span>(fx, fy);<br>    fa[fy] = fx;<br>    size[fx] += size[fy];<br>&#125;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">qread</span>(n, m);<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x, y, z, fx, fy;<br>        <span class="hljs-built_in">qread</span>(z, x, y);<br>        <span class="hljs-keyword">if</span> (z == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">merge</span>(x, y);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z == <span class="hljs-number">2</span>) &#123;<br>            fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-built_in">puts</span>(fx == fy ? <span class="hljs-string">&quot;Y&quot;</span> : <span class="hljs-string">&quot;N&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%B9%B6%E6%9F%A5%E9%9B%86&oldid=64402641">并查集 - 维基百科</a>，维基百科，2021 年 2 月 20 日 21 : 51（HKT）。</li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Disjoint-set_data_structure&oldid=1054790861">Disjoint-set data structure - Wikipedia</a>，Wikipedia，2021 年 11 月 12 日 11 : 28（HKT）。</li>
</ol>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
