<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/16107/</url>
    <content><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>新博客做好了，还在添加更多功能。</p>
]]></content>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/61809/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>并查集</strong>（英语：<strong>Disjoint-set data structure</strong>、<strong>disjoint-set data structure</strong> 或 <strong>merge–find set</strong>），是一种用于快速查询处理一些元素与集合的查询与合并的数据结构。</p>
<p>支持以下几种操作：</p>
<ul>
<li>查询：查询某个元素属于哪个集合。</li>
<li>合并：合并两个集合。</li>
<li>添加：添加一个元素作为一个新集合的元素。</li>
</ul>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>不加任何优化的并查集单次查询时间复杂度为 $O(n)$，经过路径压缩或按秩合并任意一种优化后的单次查询时间复杂度为 $O(\log n)$，如果同时使用两种优化时间复杂度则为 $O(\alpha(n))$。</p>
<p>空间复杂度为 $O(n)$。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>提供 C++ 编写，同时使用路径压缩和按秩合并优化的版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-title">qread</span><span class="hljs-params">(T &amp;n)</span> </span>&#123;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27;-&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) flag = <span class="hljs-literal">true</span>, c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) n = (n &lt;&lt; <span class="hljs-number">3</span>) + (n &lt;&lt; <span class="hljs-number">1</span>) + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();<br>    n = flag ? -n : n;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Argv&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qread</span><span class="hljs-params">(T &amp;n, Argv &amp;...argv)</span> </span>&#123;<br>    <span class="hljs-built_in">qread</span>(n), <span class="hljs-built_in">qread</span>(argv...);<br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> fa[maxn], size[maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) fa[i] = i, size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (x != fa[x]) x = fa[x] = fa[fa[x]];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (size[fx] &lt; size[fy]) <span class="hljs-built_in">swap</span>(fx, fy);<br>    fa[fy] = fx;<br>    size[fx] += size[fy];<br>&#125;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">qread</span>(n, m);<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x, y, z, fx, fy;<br>        <span class="hljs-built_in">qread</span>(z, x, y);<br>        <span class="hljs-keyword">if</span> (z == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">merge</span>(x, y);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z == <span class="hljs-number">2</span>) &#123;<br>            fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-built_in">puts</span>(fx == fy ? <span class="hljs-string">&quot;Y&quot;</span> : <span class="hljs-string">&quot;N&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%B9%B6%E6%9F%A5%E9%9B%86&oldid=64402641">并查集 - 维基百科</a>，维基百科，2021 年 2 月 20 日 21 : 51（HKT）。</li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Disjoint-set_data_structure&oldid=1054790861">Disjoint-set data structure - Wikipedia</a>，Wikipedia，2021 年 11 月 12 日 11 : 28（HKT）。</li>
</ol>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Treasures and Vikings</title>
    <url>/2021/45988/</url>
    <content><![CDATA[<p>提交地址：<a href="https://www.luogu.com.cn/problem/P4668">洛谷 Luogu4668</a>，<a href="https://www.luogu.com.cn/problem/SP10128">洛谷 SP10128</a>，<a href="https://www.spoj.com/problems/TANDV/">Sphere online judge SP10128</a>，<a href="https://sjzezoj.com/problem/1159">S2 Online Judge</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n \times m$ 的地图，地图上可能有海（<code>.</code>）、陆地（<code>I</code>）、你的船（<code>Y</code>）、维京船（<code>V</code>）和宝藏（<code>T</code>）。</p>
<p>你的目的是在不被维京人干掉的情况下得到宝藏。</p>
<p>你和维京船每回合可以移动到一个四联通块，也可以不移动，每个回合你先移动。</p>
<p>维京船会在回合结束时攻击与其在同一列或同一行的船，攻击不能穿过陆地。</p>
<p>如果有一条路径，使得无论维京船如何移动你都能得到宝藏，输出 <code>YES</code> 否则输出 <code>NO</code>。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>数据范围是 $n, m \le 700$，考虑直接广搜暴搜。</p>
<p>先看一个简单的问题：</p>
<p>有一张 $n \times m$ 的地图，地图上有个怪物，你和怪物每回合可以移动到一个四联通块，也可以不移动，问对于第 $i$ 个回合，哪里是安全的（怪物移动不到）。</p>
<p>答案很显然，直接让怪物扩展 $i$ 次，没扩展到的地方都是安全的。</p>
<p>那么这道题同理，我们每回合都让自己和维京扩展一格，然后给维京船能攻击到的地方打上标记即可。</p>
<p>注意如何打标记，我们准备两种标记，一种是竖着攻击，一种是横着攻击，如果这一格已经打过一种标记了不用再打第二次，但是另一种还是要打。</p>
<p>这样可以保证每个格最多只打两次标记，复杂度为 $O(nm)$。</p>
<p>整体复杂度 $O(nm)$。</p>
<h2 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 枚举类型，用于存储每个格子状态，这么写可以将每个状态压到一个二进制位内</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">crt</span>&#123;</span>land = <span class="hljs-number">0</span>, sea = <span class="hljs-number">1</span>, trea = <span class="hljs-number">2</span>, you = <span class="hljs-number">4</span>, youvis = <span class="hljs-number">8</span>, vik = <span class="hljs-number">16</span>, vikvis = <span class="hljs-number">32</span>, atkw = <span class="hljs-number">64</span>, atkh = <span class="hljs-number">128</span>&#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">705</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> t)</span> </span>&#123;<br>    <span class="hljs-built_in">puts</span>(t ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">int</span> mp[maxn][maxn];<br><span class="hljs-keyword">char</span> s[maxn];<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> yx, yy, vx, vy, sx, sy;<br><span class="hljs-comment">// 给维京船能攻击到的地方打标记</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vikatk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    mp[x][y] |= vikvis;<br>    <span class="hljs-keyword">if</span> (!(mp[x][y] &amp; atkw)) &#123; <span class="hljs-comment">// 打过了跳，下面同理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = y; j &gt; <span class="hljs-number">0</span>; --j)<br>            <span class="hljs-keyword">if</span> (mp[x][j] &amp; sea)<br>                mp[x][j] |= atkw;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = y; j &lt;= m; ++j)<br>            <span class="hljs-keyword">if</span> (mp[x][j] &amp; sea)<br>                mp[x][j] |= atkw;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(mp[x][y] &amp; atkh)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &gt; <span class="hljs-number">0</span>; --i)<br>            <span class="hljs-keyword">if</span> (mp[i][y] &amp; sea)<br>                mp[i][y] |= atkh;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt;= n; ++i)<br>            <span class="hljs-keyword">if</span> (mp[i][y] &amp; sea)<br>                mp[i][y] |= atkh;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> x, y, p;<br>&#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>queue&lt;node&gt; vm;<br>queue&lt;node&gt; ym;<br><span class="hljs-comment">// 维京船移动</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vikmove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    ++p;<br>    <span class="hljs-keyword">while</span> (!vm.<span class="hljs-built_in">empty</span>() &amp;&amp; vm.<span class="hljs-built_in">front</span>().p &lt;= p) &#123;<br>        <span class="hljs-keyword">int</span> x = vm.<span class="hljs-built_in">front</span>().x, y = vm.<span class="hljs-built_in">front</span>().y;<br>        vm.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k) &#123;<br>            <span class="hljs-keyword">int</span> tx = x + dx[k], ty = y + dy[k];<br>            <span class="hljs-keyword">if</span> (mp[tx][ty] == land) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!(mp[tx][ty] &amp; vikvis)) &#123;<br>                vm.<span class="hljs-built_in">push</span>(&#123;tx, ty, p + <span class="hljs-number">1</span>&#125;);<br>                <span class="hljs-built_in">vikatk</span>(tx, ty);<br>                <span class="hljs-comment">// 如果维京船打到了宝藏就不可能能拿到了</span><br>                <span class="hljs-keyword">if</span> ((mp[sx][sy] &amp; atkh) || (mp[sx][sy] &amp; atkw)) <span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自己移动</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">youmove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    ++p;<br>    <span class="hljs-keyword">while</span> (!ym.<span class="hljs-built_in">empty</span>() &amp;&amp; ym.<span class="hljs-built_in">front</span>().p &lt;= p) &#123;<br>        <span class="hljs-keyword">int</span> x = ym.<span class="hljs-built_in">front</span>().x, y = ym.<span class="hljs-built_in">front</span>().y;<br>        ym.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 如果这个位置被打了就不能扩展</span><br>        <span class="hljs-keyword">if</span> ((mp[x][y] &amp; atkw) || (mp[x][y] &amp; atkh)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k) &#123;<br>            <span class="hljs-keyword">int</span> tx = x + dx[k], ty = y + dy[k];<br>            <span class="hljs-keyword">if</span> (mp[tx][ty] == land) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!((mp[tx][ty] &amp; youvis) || (mp[tx][ty] &amp; atkw) || (mp[tx][ty] &amp; atkh))) &#123;<br>                mp[tx][ty] |= youvis;<br>                ym.<span class="hljs-built_in">push</span>(&#123;tx, ty, p + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (s[j]) &#123; <span class="hljs-comment">// 存状态</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>: mp[i][j] = sea; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: mp[i][j] = land; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Y&#x27;</span>: mp[i][j] = sea | you | youvis;<br>                          yx = i, yy = j;<br>                          <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>: mp[i][j] = sea | vik | vikvis;<br>                          vx = i, vy = j;<br>                          <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;T&#x27;</span>: mp[i][j] = sea | trea;<br>                          sx = i, sy = j;<br>                          <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-comment">// 初始状态入队</span><br>    ym.<span class="hljs-built_in">push</span>(&#123;yx, yy, <span class="hljs-number">1</span>&#125;);<br>    vm.<span class="hljs-built_in">push</span>(&#123;vx, vy, <span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!(ym.<span class="hljs-built_in">empty</span>() &amp;&amp; vm.<span class="hljs-built_in">empty</span>())) &#123;<br>        <span class="hljs-built_in">youmove</span>();<br>        <span class="hljs-built_in">vikmove</span>();<br>        <span class="hljs-comment">// 得到了</span><br>        <span class="hljs-keyword">if</span> (mp[sx][sy] &amp; youvis) <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 死路</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
</search>
