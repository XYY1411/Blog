<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>加法逆元, Additive Inverse</title>
    <url>/53088/</url>
    <content><![CDATA[<p>其实就是相反数。</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">additive_inverse</span><span class="params">(T n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>加法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI大纲</title>
    <url>/44518/</url>
    <content><![CDATA[<p>终于有个规范了。</p>
<span id="more"></span>

<div  style="text-align: center;"><a href="https://xyy1411.github.io/44518/NOI%E5%A4%A7%E7%BA%B2.pdf" download="https://xyy1411.github.io/44518/NOI%E5%A4%A7%E7%BA%B2.pdf">NOI大纲</a></div>]]></content>
      <categories>
        <category>资料</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOI大纲</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Bash 常用命令</title>
    <url>/17383/</url>
    <content><![CDATA[<p> 用于 OI 。</p>
<span id="more"></span>

<h1 id="Linux-Bash-常用命令"><a href="#Linux-Bash-常用命令" class="headerlink" title="Linux Bash 常用命令"></a>Linux Bash 常用命令</h1><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a><code>diff</code></h2><p><code>diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]</code></p>
<p>-&lt;行数&gt; 　指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</p>
<p>-a或–text 　diff预设只会逐行比较文本文件。</p>
<p>-b或–ignore-space-change 　不检查空格字符的不同。</p>
<p>-B或–ignore-blank-lines 　不检查空白行。</p>
<p>-c 　显示全部内文，并标出不同之处。</p>
<p>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。</p>
<p>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。</p>
<p>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。</p>
<p>-e或–ed 　此参数的输出格式可用于ed的script文件。</p>
<p>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</p>
<p>-H或–speed-large-files 　比较大文件时，可加快速度。</p>
<p>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</p>
<p>-i或–ignore-case 　不检查大小写的不同。</p>
<p>-l或–paginate 　将结果交由pr程序来分页。</p>
<p>-n或–rcs 　将比较结果以RCS的格式来显示。</p>
<p>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</p>
<p>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</p>
<p>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</p>
<p>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</p>
<p>-q或–brief 　仅显示有无差异，不显示详细的信息。</p>
<p>-r或–recursive 　比较子目录中的文件。</p>
<p>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。</p>
<p>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。</p>
<p>-t或–expand-tabs 　在输出时，将tab字符展开。</p>
<p>-T或–initial-tab 　在每行前面加上tab字符以便对齐。</p>
<p>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。</p>
<p>-v或–version 　显示版本信息。</p>
<p>-w或–ignore-all-space 　忽略全部的空格字符。</p>
<p>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。</p>
<p>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。</p>
<p>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。</p>
<p>-y或–side-by-side 　以并列的方式显示文件的异同之处。</p>
<p>–help 　显示帮助。</p>
<p>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</p>
<p>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h2><p><code>rm [options] name...</code></p>
<p>-i 删除前逐一询问确认。</p>
<p>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</p>
<p>-r 将目录及以下之档案亦逐一删除。</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h2><p><code>cp [options] source dest</code> or <code>cp [options] source... directory</code></p>
<p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</p>
<p>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</p>
<p>-f：覆盖已经存在的目标文件而不给出提示。</p>
<p>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</p>
<p>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</p>
<p>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</p>
<p>-l：不复制文件，只是生成链接文件。</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h2><p><code>cd [dirName]</code></p>
<p>dirName：要切换的目标目录。</p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h2><p><code>mkdir [-p] dirName</code></p>
<p>-p 确保目录名称存在，不存在的就建一个。</p>
<h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a><code>tree</code></h2><p><code>tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录...]</code></p>
<p>-a 显示所有文件和目录。</p>
<p>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</p>
<p>-C 在文件和目录清单加上色彩，便于区分各种类型。</p>
<p>-d 显示目录名称而非内容。</p>
<p>-D 列出文件或目录的更改时间。</p>
<p>-f 在每个文件或目录之前，显示完整的相对路径名称。</p>
<p>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。</p>
<p>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</p>
<p>-i 不以阶梯状列出文件或目录名称。</p>
<p>-L level 限制目录显示层级。</p>
<p>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</p>
<p>-n 不在文件和目录清单加上色彩。</p>
<p>-N 直接列出文件和目录名称，包括控制字符。</p>
<p>-p 列出权限标示。</p>
<p>-P&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</p>
<p>-q 用”?”号取代控制字符，列出文件和目录名称。</p>
<p>-s 列出文件或目录大小。</p>
<p>-t 用文件和目录的更改时间排序。</p>
<p>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</p>
<p>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h2><p><code>ls [-alrtAFR] [name...]</code></p>
<p>-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)。</p>
<p>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出。</p>
<p>-r 将文件以相反次序显示(原定依英文字母次序)。</p>
<p>-t 将文件依建立时间之先后次序列出。</p>
<p>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)。</p>
<p>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“。</p>
<p>-R 若目录下有文件，则以下之文件亦皆依序列出。</p>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a><code>sudo</code></h2><p>以系统管理者的身份执行指令。</p>
<h2 id="su"><a href="#su" class="headerlink" title="su"></a><code>su</code></h2><p><code>su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</code></p>
<p>-f 或 –fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh。</p>
<p>-m -p 或 –preserve-environment 执行 su 时不改变环境变数。</p>
<p>-c command 或 –command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者。</p>
<p>-s shell 或 –shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell。</p>
<p>–help 显示说明文件。</p>
<p>–version 显示版本资讯。</p>
<p>–l 或 –login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root。</p>
<p>USER 欲变更的使用者帐号。</p>
<p>ARG 传入新的 shell 参数。</p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a><code>zip</code></h2><p><code>zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件...][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]</code></p>
<p>-A 调整可执行的自动解压缩文件。</p>
<p>-b&lt;工作目录&gt; 指定暂时存放文件的目录。</p>
<p>-c 替每个被压缩的文件加上注释。</p>
<p>-d 从压缩文件内删除指定的文件。</p>
<p>-D 压缩文件内不建立目录名称。</p>
<p>-f 更新现有的文件。</p>
<p>-F 尝试修复已损坏的压缩文件。</p>
<p>-g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</p>
<p>-h 在线帮助。</p>
<p>-i&lt;范本样式&gt; 只压缩符合条件的文件。</p>
<p>-j 只保存文件名称及其内容，而不存放任何目录名称。</p>
<p>-J 删除压缩文件前面不必要的数据。</p>
<p>-k 使用MS-DOS兼容格式的文件名称。</p>
<p>-l 压缩文件时，把LF字符置换成LF+CR字符。</p>
<p>-ll 压缩文件时，把LF+CR字符置换成LF字符。</p>
<p>-L 显示版权信息。</p>
<p>-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</p>
<p>-n&lt;字尾字符串&gt; 不压缩具有特定字尾字符串的文件。</p>
<p>-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</p>
<p>-q 不显示指令执行过程。</p>
<p>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</p>
<p>-S 包含系统和隐藏文件。</p>
<p>-t&lt;日期时间&gt; 把压缩文件的日期设成指定的日期。</p>
<p>-T 检查备份文件内的每个文件是否正确无误。</p>
<p>-u 与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</p>
<p>-v 显示指令执行过程或显示版本信息。</p>
<p>-V 保存VMS操作系统的文件属性。</p>
<p>-w 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</p>
<p>-x&lt;范本样式&gt; 压缩时排除符合条件的文件。</p>
<p>-X 不保存额外的文件属性。</p>
<p>-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</p>
<p>-z 替压缩文件加上注释。</p>
<p>-$ 保存第一个被压缩文件所在磁盘的卷册名称。</p>
<p>-&lt;压缩效率&gt; 压缩效率是一个介于1-9的数值。</p>
<h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a><code>unzip</code></h2><p><code>unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</code></p>
<p>-c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。</p>
<p>-f 更新现有的文件。</p>
<p>-l 显示压缩文件内所包含的文件。</p>
<p>-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</p>
<p>-t 检查压缩文件是否正确。</p>
<p>-u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</p>
<p>-v 执行是时显示详细的信息。</p>
<p>-z 仅显示压缩文件的备注文字。</p>
<p>-a 对文本文件进行必要的字符转换。</p>
<p>-b 不要对文本文件进行字符转换。</p>
<p>-C 压缩文件中的文件名称区分大小写。</p>
<p>-j 不处理压缩文件中原有的目录路径。</p>
<p>-L 将压缩文件中的全部文件名改为小写。</p>
<p>-M 将输出结果送到more程序处理。</p>
<p>-n 解压缩时不要覆盖原有的文件。</p>
<p>-o 不必先询问用户，unzip执行后覆盖原有文件。</p>
<p>-P&lt;密码&gt; 使用zip的密码选项。</p>
<p>-q 执行时不显示任何信息。</p>
<p>-s 将文件名中的空白字符转换为底线字符。</p>
<p>-V 保留VMS的文件版本信息。</p>
<p>-X 解压缩时同时回存文件原来的UID/GID。</p>
<p>[.zip文件] 指定.zip压缩文件。</p>
<p>[文件] 指定要处理.zip压缩文件中的哪些文件。</p>
<p>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</p>
<p>-x&lt;文件&gt; 指定不要处理.zip压缩文件中的哪些文件。</p>
<p>-Z unzip -Z等于执行zipinfo指令。</p>
<h2 id="killall"><a href="#killall" class="headerlink" title="killall"></a><code>killall</code></h2><p><code>killall [选项]  name</code></p>
<p>name ： 进程名。</p>
<p>-e | –exact ： 进程需要和名字完全相符。</p>
<p>-I | –ignore-case ：忽略大小写。</p>
<p>-g | –process-group ：结束进程组。</p>
<p>-i | –interactive ：结束之前询问。</p>
<p>-l | –list ：列出所有的信号名称。</p>
<p>-q | –quite ：进程没有结束时，不输出任何信息。</p>
<p>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</p>
<p>-s | –signal ：发送指定信号。</p>
<p>-u | –user ：结束指定用户的进程。</p>
<p>-v | –verbose ：显示详细执行过程。</p>
<p>-w | –wait ：等待所有的进程都结束。</p>
<p>-V |–version ：显示版本信息。</p>
<p>–help ：显示帮助信息。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>裴蜀定理, Bézout&#39;s lemma</title>
    <url>/46515/</url>
    <content><![CDATA[<p>又叫贝祖定理。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F">维基百科</a>，<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86">百度百科</a>，<a href="https://oi-wiki.org/math/bezouts/">OI Wiki</a></p>
<p>$\forall x, y \neq 0， \exists x, y \in \mathbb{Z},$ 使得 $ax +by = (a, b)$.</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>裴蜀定理</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开</title>
    <url>/63067/</url>
    <content><![CDATA[<p><del>反正乱推就完事了。</del></p>
<span id="more"></span>

<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><p>康托展开可以求一个 $1 \sim n$ 的任意排列的排名。</p>
<h2 id="变进制数"><a href="#变进制数" class="headerlink" title="变进制数"></a>变进制数</h2><p>字面意思。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定无穷数集 $S = {a_0, a_1, a_2, \cdots, a_n, \cdots}, a_0 = 1$，定义变进制数为第 $i$ 位的单位是上一位单位的 $a_i$ 倍。</p>
<p>则有变进制数 $(A)_S = \overline{x_n x_{n - 1} \cdots x_1 x_0}, 0 \le x_i &lt; a_{i + 1}$。</p>
<p>类似于其他不变进制数，如十进制为每位满 $10$ 进 $1$，而变进制数则为第 $i$ 位满 $a_{i + 1}$ 进 $1$。</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>将变进制数转化为十进制数也与不变进制数类似，如二进制转十进制为第 $i$ 位乘上 $2^i$，而变进制数则为乘上 $\prod_{j = 0}^i a_j$，即：</p>
<p>$$\begin{aligned} A_{10} &amp;= \sum_{i = 0}^n (x_i \prod_{j = 0}^i a_j) \\ &amp;= x_n \prod_{i = 0}^n a_i + x_{n - 1} \prod_{i = 0}^{n - 1} + \cdots + x_1 a_1 a_0 + x_0 a_0 \end{aligned}$$</p>
<p>将不变进制数转变进制数，同理，用短除法除每一位 $a_i$ 然后取余数为答案。</p>
<h3 id="rm-color-green-code"><a href="#rm-color-green-code" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变进制数转十进制数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Stod</span><span class="params">(T *a, T *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; ~i; --i) A = (A + x[i]) * a[i];</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 十进制数转变进制数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dtoS</span><span class="params">(T A, T *a, T *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; A; ++i) x[i] = A % a[i + <span class="number">1</span>], A /= a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="广义康托展开"><a href="#广义康托展开" class="headerlink" title="广义康托展开"></a>广义康托展开</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>广义康托展开即给定两个变进制 $S_1, S_2$ 和 $(A)_{S_1}$，求 $(A)_{S_2}$。</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>我们现在不知道怎么将一个变进制数转换为另一个变进制数，但我们知道如何将一个变进制数转为十进制数和如何将十进制数转为变进制数，于是我们就可以将十进制数作为中转来将一个变进制数转换为另一个变进制数。</p>
<h3 id="rm-color-green-code-1"><a href="#rm-color-green-code-1" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">StoS</span><span class="params">(T *a1, T *x1, T *a2, T *x2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; ~i; --i) A = (A + x1[i]) * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; A; ++i) x2[i] = A % a2[i + <span class="number">1</span>], A /= a2[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="阶乘进制数"><a href="#阶乘进制数" class="headerlink" title="阶乘进制数"></a>阶乘进制数</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>$a_i = i(i \neq 0)$ 的变进制数 $(A)_! = \overline{x_n x_{n - 1} \cdots x_1 x_0}$ 称为阶乘进制数。</p>
<p>则阶乘进制转十进制有</p>
<div class="math-fluid">

<p>$$\begin{aligned} A_{10} &amp;= \sum_{i = 0}^n (x_i \prod_{j = 0}^i a_j) = \sum_{i = 0}^n (x_i \prod_{j = 0}^i (j, j \neq 0 : 1, j = 0)) \\ &amp;= \sum_{i = 0}^n (x_i i!) = x_n n! + x_{n - 1} (n - 1)! + \cdot + x_2 2! + x_1 1! + x_0 1 \end{aligned}$$</p>
</div>

<h2 id="康托展开-1"><a href="#康托展开-1" class="headerlink" title="康托展开"></a>康托展开</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>将任意十进制数转为阶乘进制数。</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>直接套公式即可。</p>
<h3 id="rm-color-green-code-2"><a href="#rm-color-green-code-2" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cantor_exp</span><span class="params">(T A, T *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; A; ++i) x[i] = A % (i + <span class="number">1</span>), A /= (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>字面意思，将阶乘进制数转十进制。</p>
<h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>直接套公式即可。</p>
<h3 id="rm-color-green-code-3"><a href="#rm-color-green-code-3" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">inv_cantor_exp</span><span class="params">(T *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; ~i; --i) A = (A + x[i]) * (i == <span class="number">0</span> ? <span class="number">1</span> : i);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="排列与阶乘进制数"><a href="#排列与阶乘进制数" class="headerlink" title="排列与阶乘进制数"></a>排列与阶乘进制数</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>任何一个 $1, \cdots, n$ 的排列都对应一个唯一的阶乘进制数。</p>
<p>那么我们可以使 $x_i$ 为 $p_i$ 在后缀 ${p_i, p_{i + 1},  \cdots, p_n}$ 中的排名，排名从 $0$ 开始。</p>
<p>这样我们就可以将排列转变为阶乘进制数。</p>
<p>但是直接这样算的复杂度是 $\Omicron(n^2)$ 的，太高，我们需要更低的复杂度。</p>
<p>观察计算过程，发现最消耗时间的是查询后缀排名这一步。</p>
<p>动态查询排名可以用平衡树，复杂度为 $\Omicron(\log n)$，但是编程复杂程度太高。</p>
<p>树状数组是 $\Omicron(\log^2 n)$ 的。</p>
<p>考虑线段树，我们可以在线段树上二分查询排名，复杂度也是 $\Omicron(\log n)$，但是易实现。</p>
<p>还有树状数组上二分，不会。</p>
<p>这样总复杂度为 $\Omicron(n \log n)$。</p>
<p>代码见下面例题</p>
<h2 id="例题：-NOIP2004-普及组-火星人"><a href="#例题：-NOIP2004-普及组-火星人" class="headerlink" title="例题：[NOIP2004 普及组] 火星人"></a>例题：[NOIP2004 普及组] 火星人</h2><p>提交地址：<a href="https://www.luogu.com.cn/problem/P1088">洛谷 Luogu1088</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定 $1, \cdots, n (n \le 10^3)$ 的排列 $p_1, p_2, \cdots, p_n$ 和正整数 $m (m \le 100)$。</p>
<p>设当前排列的排名为 $rank$，求排名为 $rank + m$ 的排列。</p>
<h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><p>原题数据范围很小，我们只要暴力枚举排列即可。</p>
<h3 id="rm-color-green-code-4"><a href="#rm-color-green-code-4" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> s[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">next_permutation</span>(s, s + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>更改数据范围为 $n \le 10^5, k \le 10^{18}$。</p>
<h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>现在暴力过不去了，考虑康托展开，我们直接展开为一个阶乘进制数，然后加上 $m$ 再转回去就好了，复杂度是 $\Omicron(n \log n)$ 的。</p>
<h3 id="rm-color-green-code-5"><a href="#rm-color-green-code-5" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h3><details>
    <summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line">ll c[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; c[p] = c[<span class="built_in">ls</span>(p)] + c[<span class="built_in">rs</span>(p)]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        c[p] += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= m)</span><br><span class="line">        <span class="built_in">plus</span>(<span class="built_in">ls</span>(p), l, m, t, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">plus</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, r, t, x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询和</span></span><br><span class="line"><span class="function">ll <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt; l || r &lt; ql)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> c[p];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        res += <span class="built_in">query_sum</span>(<span class="built_in">ls</span>(p), l, m, ql, qr);</span><br><span class="line">        res += <span class="built_in">query_sum</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询排名</span></span><br><span class="line"><span class="function">ll <span class="title">query_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= c[<span class="built_in">ls</span>(p)] ? <span class="built_in">query_rank</span>(<span class="built_in">ls</span>(p), l, m, cnt)</span><br><span class="line">                           : <span class="built_in">query_rank</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, r, cnt - c[<span class="built_in">ls</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, dlt;</span><br><span class="line">ll x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;dlt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x[i]);</span><br><span class="line">    <span class="comment">// 转换为阶乘进制数，注意是倒着的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="built_in">plus</span>(<span class="number">1</span>, <span class="number">1</span>, n, x[i], <span class="number">1</span>);</span><br><span class="line">        x[i] = <span class="built_in">query_sum</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x[i]) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上 m，处理进位</span></span><br><span class="line">    x[n] += dlt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">1</span>; i &amp;&amp; x[i] &gt;= j; --i, ++j) &#123;</span><br><span class="line">        x[i - <span class="number">1</span>] += x[i] / j;</span><br><span class="line">        x[i] %= j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转回去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        x[i] = <span class="built_in">query_rank</span>(<span class="number">1</span>, <span class="number">1</span>, n, x[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">plus</span>(<span class="number">1</span>, <span class="number">1</span>, n, x[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, x[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>后面没写完。</p>
<!--

板板

给定 $1, \cdots, n (n \le 10^5)$ 的排列 $p_1, p_2, \cdots, p_n$ 和一个正整数 $\alpha$：

操作一：将当前排列排名增加 $k (k \le 10^18)$

操作二：输出当前排列对应的 $\sum_{i = 1}^n p_i \times \alpha^i \bmod 998244353$

Bonus：操作一改为继承历史版本， $\alpha$ 随询问给出。

逆序对

查逆序对

多重集排列

--> ]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>素数</title>
    <url>/26915/</url>
    <content><![CDATA[<p>数论的基础（？）</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E8%B4%A8%E6%95%B0">维基百科</a>，<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fromtitle=%E7%B4%A0%E6%95%B0&fromid=115069">百度百科</a>，<a href="https://oi-wiki.org/math/prime/">OI Wiki</a></p>
<p>质数，又称素数，指在大于 $1$ 的自然数中，除了 $1$ 和该数自身外，无法被其他自然数整除的数。大于 $1$ 的自然数若不是素数，则称之为合数。</p>
<h1 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h1><p>那么如何判断一个数是不是素数？<del>（傻子都会吧）</del></p>
<p>就是一个一个试着去除。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>$\Theta(\sqrt n)$</p>
<h2 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(T n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理, Chinese remainder theorem, crt</title>
    <url>/8769/</url>
    <content><![CDATA[<p>emmm…</p>
<p>孙子定理感觉不好听……</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">crt</span><span class="params">(T n, T *ai, T *mi)</span> </span>&#123;</span><br><span class="line">    T m = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    T *M = <span class="keyword">new</span> T[n + <span class="number">5</span>];</span><br><span class="line">    T *invM = <span class="keyword">new</span> T[n + <span class="number">5</span>];</span><br><span class="line">    T *c = <span class="keyword">new</span> T[n + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">1</span>; i &lt;= n; ++i) m *= mi[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">1</span>; i &lt;= n; ++i) M[i] = m / mi[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">1</span>; i &lt;= n; ++i) invM[i] = <span class="built_in">inverse_extgcd</span>(M[i], mi[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = M[i] * invM[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">1</span>; i &lt;= n; ++i) ans = (ans + ai[i] * c[i] % m) % m;</span><br><span class="line">    <span class="keyword">delete</span>[] M;</span><br><span class="line">    <span class="keyword">delete</span>[] invM;</span><br><span class="line">    <span class="keyword">delete</span>[] c;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>中国剩余定理, crt</tag>
        <tag>同余</tag>
        <tag>扩展欧几里得算法, extgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>普通快读</title>
    <url>/40753/</url>
    <content><![CDATA[<p>最普通的快读。</p>
<span id="more"></span>

<p>不使用 <code>std::scanf()</code> 中的格式输入以提高输入速度。</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><h2 id="rm-OI"><a href="#rm-OI" class="headerlink" title="$\rm OI$"></a>$\rm OI$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">qread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch != <span class="string">&#x27;-&#x27;</span>)) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (flag) n = -n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rm-P"><a href="#rm-P" class="headerlink" title="$\rm P$"></a>$\rm P$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fqreadi</span><span class="params">(T &amp;n, FILE *fp)</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = std::<span class="built_in">getc</span>(fp);</span><br><span class="line">    <span class="keyword">while</span> (!std::<span class="built_in">isdigit</span>(ch) &amp;&amp; (ch ^ <span class="number">45</span>) &amp;&amp; (ch ^ EOF)) ch = std::<span class="built_in">getc</span>(fp);</span><br><span class="line">    <span class="keyword">if</span> (!(ch ^ EOF)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ch ^ <span class="number">45</span>)) flag = <span class="literal">true</span>, ch = std::<span class="built_in">getc</span>(fp);</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = std::<span class="built_in">getc</span>(fp);</span><br><span class="line">    <span class="keyword">if</span> (flag) n = (~n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(ch ^ EOF)) std::<span class="built_in">ungetc</span>(ch, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">qreadi</span><span class="params">(T &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fqreadi</span>(n, stdin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>快读</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解, prime factorization</title>
    <url>/42604/</url>
    <content><![CDATA[<p>小学……数奥？</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">divide</span><span class="params">(T n, T *p, T *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p[++cnt] = i, c[cnt] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i, c[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) p[++cnt] = n, c[cnt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>埃拉托斯特尼筛法, κόσκινον Ἐρατοσθένους</title>
    <url>/48233/</url>
    <content><![CDATA[<p>一个古老的算法。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">维基百科</a>，<a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">百度百科</a>，<a href="https://oi-wiki.org/math/sieve/#_2">OI Wiki</a></p>
<p>埃筛是一种质数筛主要思想是每遇到一个数就把他的倍数全划掉，剩下的就是素数了。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>$\Theta(n \log \log n)$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><h2 id="rm-OI"><a href="#rm-OI" class="headerlink" title="$\rm OI$"></a>$\rm OI$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_prime[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime[p++] = i;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)i * i &lt;= n)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) is_prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rm-P"><a href="#rm-P" class="headerlink" title="$\rm P$"></a>$\rm P$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">get_prime_eratosthenes</span><span class="params">(T n, <span class="keyword">bool</span> *isprime, T *prime_table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    T p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i) isprime[i] = <span class="literal">true</span>;</span><br><span class="line">    isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            prime_table[++p] = i;</span><br><span class="line">            <span class="keyword">for</span> (T j = i * i; j &lt;= n; j += i) isprime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>筛法</tag>
        <tag>埃拉托斯特尼筛法, Eratosthenes</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法, 辗转相除法 Euclidean algorithm, gcd</title>
    <url>/56234/</url>
    <content><![CDATA[<p>GCD… 应该没人不会吧……</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">维基百科</a>，<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">百度百科</a>，<a href="https://oi-wiki.org/math/gcd/#_2">OI Wiki</a></p>
<p>$$(a, b) = \begin{cases} a ,&amp; b = 0 \\ (b,\, a \mod b) , &amp; b \neq 0 \end{cases}$$</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>$\Theta(\log n)$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd&lt;T&gt;(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">lcm</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a / gcd&lt;T&gt;(a, b) * b;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>欧几里得算法, 辗转相除法, gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉定理（数论）, Euler&#39;s theorem(Number Theory)</title>
    <url>/9023/</url>
    <content><![CDATA[<p><del>不是几何！</del></p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>若 $(a, m) = 1$ ， 则有：</p>
<p>$$a^{\varphi(m)} \equiv 1 \pmod m$$</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>欧拉定理（数论）</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数, Euler function</title>
    <url>/55226/</url>
    <content><![CDATA[<p>第一次看的时候我直接晕。</p>
<span id="more"></span>

<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><h2 id="rm-P"><a href="#rm-P" class="headerlink" title="# $\rm P$"></a># $\rm P$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">phi</span><span class="params">(T n)</span> </span>&#123;</span><br><span class="line">    T ans = n;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-03-22 模拟赛</title>
    <url>/23060/</url>
    <content><![CDATA[<p>emmmm~ </p>
<span id="more"></span>

<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>是区间DP，很容易就看出来了，然而题目出的却不知道如何合并……于是爆零。</p>
<h1 id="T2-NOIP2014-提高组-飞扬的小鸟"><a href="#T2-NOIP2014-提高组-飞扬的小鸟" class="headerlink" title="T2 [NOIP2014 提高组] 飞扬的小鸟"></a>T2 [NOIP2014 提高组] 飞扬的小鸟</h1><p>貌似特判写挂了卡掉了25pts。</p>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>是树形DP + 二次扫描换根，然而没复习到想写暴力发现图论忘光 dfs 都写挂了。</p>
<h1 id="合计-0-75-0-75"><a href="#合计-0-75-0-75" class="headerlink" title="合计 $0 + 75 + 0 = 75$"></a>合计 $0 + 75 + 0 = 75$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>动态规划, DP</tag>
        <tag>区间动态规划, 区间DP</tag>
        <tag>树上动态规划, 树形DP</tag>
        <tag>二次扫描换根</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-02 模拟赛</title>
    <url>/23275/</url>
    <content><![CDATA[<p>莫名其妙 $\rm\color{Yellow}CE$ 了， $\rm\color{Yellow}CE$ 太难受了。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-分解因数"><a href="#T1-分解因数" class="headerlink" title="T1 分解因数"></a>T1 分解因数</h2><p><a href="div.cpp" download="div.cpp">考场代码</a></p>
<p>提交地址：<a href="http://bailian.openjudge.cn/practice/2749/">百炼 PKU2749</a></p>
<p>$n \le 100$ 的大水题，直接暴力枚举。</p>
<h2 id="T2-UNOI2020-B-卡牌游戏"><a href="#T2-UNOI2020-B-卡牌游戏" class="headerlink" title="T2 [UNOI2020-B] 卡牌游戏"></a>T2 [UNOI2020-B] 卡牌游戏</h2><p><a href="card.cpp" download="card.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P6625/">洛谷 Luogu6625</a></p>
<p>前缀和的大水题。</p>
<h2 id="T3-NOIP2012-提高组-开车旅行"><a href="#T3-NOIP2012-提高组-开车旅行" class="headerlink" title="T3 [NOIP2012 提高组] 开车旅行"></a>T3 [NOIP2012 提高组] 开车旅行</h2><p><a href="drive.cpp" download="drive.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P1081/">洛谷 Luogu1081</a></p>
<p>正解是倍增优化 DP ，但是不会，写了个优化暴力，应该有 70 分来着，但是和 GNU 内置函数重载出错了，直接 $70 \rightarrow 0$ 。</p>
<h1 id="合计-100-100-0-200"><a href="#合计-100-100-0-200" class="headerlink" title="合计 $100 + 100 + 0 = 200$"></a>合计 $100 + 100 + 0 = 200$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>动态规划, DP</tag>
        <tag>前缀和</tag>
        <tag>倍增</tag>
        <tag>倍增优化动态规划, 倍增优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛, sieve of Euler</title>
    <url>/51755/</url>
    <content><![CDATA[<p>线性质数筛。</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">  inline T get_prime_euler(T n, bool *isprime, T *prime_table);</span></span><br><span class="line"><span class="comment">  求 n 以下的质数表</span></span><br><span class="line"><span class="comment">  T 必须为整形类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">get_prime_euler</span><span class="params">(T n, <span class="keyword">bool</span> *isprime, T *prime_table)</span> </span>&#123;</span><br><span class="line">    T p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i) isprime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) prime_table[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (T j = <span class="number">1</span>, t; j &lt; p &amp;&amp; (t = i * prime_table[j]) &lt;= n; ++j) &#123;</span><br><span class="line">            isprime[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime_table[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>筛法</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-11模拟赛</title>
    <url>/55679/</url>
    <content><![CDATA[<p>又莫名其妙 $\rm\color{Yellow}CE$ 了， $\rm\color{Yellow}CE$ 太难受了。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-胡萝卜"><a href="#T1-胡萝卜" class="headerlink" title="T1 胡萝卜"></a>T1 胡萝卜</h2><p><a href="carrot.cpp" download="carrot.cpp">考场代码</a></p>
<p>提交地址：<a href="http://192.168.0.111:1926/problem/61/">SIGSEGV OJ SSOJ61</a></p>
<p>并查集，然而忘了 <code>i * j</code> 会过程中爆 <code>long long</code> 。</p>
<h2 id="T2-序列"><a href="#T2-序列" class="headerlink" title="T2 序列"></a>T2 序列</h2><p><a href="sequence.cpp" download="sequence.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P1645">洛谷 Luogu1645</a>，<a href="http://192.168.0.111:1926/problem/62/">SSOJ62</a></p>
<p>贪心，然而 $\color{Yellow}CE$ 了。</p>
<h2 id="T3-min"><a href="#T3-min" class="headerlink" title="T3 min"></a>T3 min</h2><p><a href="min.cpp" download="min.cpp">考场代码</a></p>
<p>提交地址：<a href="http://192.168.0.111:1926/problem/63/">SIGSEGV OJ SSOJ63</a></p>
<p>最小生成树。</p>
<h1 id="合计-40-0-45-85"><a href="#合计-40-0-45-85" class="headerlink" title="合计 $40 + 0 + 45 = 85$"></a>合计 $40 + 0 + 45 = 85$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>贪心</tag>
        <tag>克鲁斯卡尔算法, Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-19 模拟赛</title>
    <url>/48435/</url>
    <content><![CDATA[<p>这次虽然没有 $\rm\color{Yellow}CE$ ，但是 IDA* 写挂了……</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-最小值"><a href="#T1-最小值" class="headerlink" title="T1 最小值"></a>T1 最小值</h2><p><a href="min.cpp" download="min.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>前缀和排序判长度，写个了讨论不全的贪心，但是由于数据过于水，还是过了。</p>
<h2 id="T2-15数码"><a href="#T2-15数码" class="headerlink" title="T2 15数码"></a>T2 15数码</h2><p><a href="puzzle.cpp" download="puzzle.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>正解是 IDA* ，写了个  A* 就挂了</p>
<h2 id="T3-债务清单"><a href="#T3-债务清单" class="headerlink" title="T3 债务清单"></a>T3 债务清单</h2><p><a href="gift.cpp" download="gift.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P2428">洛谷 Lougu2428</a></p>
<p>搜索， 直接 <code>puts(&quot;IMPOSSIBLE&quot;);</code> 了，写高斯消元有 50 分。</p>
<h1 id="合计-100-0-10-110"><a href="#合计-100-0-10-110" class="headerlink" title="合计 $100 + 0 + 10 = 110$"></a>合计 $100 + 0 + 10 = 110$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>搜索</tag>
        <tag>迭代加深的启发式搜索, IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-09 模拟赛</title>
    <url>/49102/</url>
    <content><![CDATA[<p>过于水的模拟赛。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-Teams"><a href="#T1-Teams" class="headerlink" title="T1 Teams"></a>T1 Teams</h2><p><a href="teams.cpp" download="teams.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>字符串哈希预处理，枚举子集暴力处理，然而直接暴力都过了， $\rm{\color{Black}L\color{Red}awrenceSivan}$ 却没写出来。</p>
<h2 id="T2-NOI2014-动物园"><a href="#T2-NOI2014-动物园" class="headerlink" title="T2  [NOI2014] 动物园"></a>T2  [NOI2014] 动物园</h2><p><a href="zoo.cpp" download="zoo.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P2375">洛谷 Luogu2375</a>，大视野在线评测 BZOJ3670 </p>
<p>一道升级 $\rm KMP$ 。</p>
<h2 id="T3-消灭恶魔"><a href="#T3-消灭恶魔" class="headerlink" title="T3 消灭恶魔"></a>T3 消灭恶魔</h2><p><a href="demon.cpp" download="demon.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>求二维凸包面积，直接叉乘即可。</p>
<h1 id="合计-100-100-100-300"><a href="#合计-100-100-100-300" class="headerlink" title="合计 $100 + 100 + 100 = 300$"></a>合计 $100 + 100 + 100 = 300$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>字符串哈希</tag>
        <tag>克努斯-莫里斯-普拉特算法, KMP</tag>
        <tag>计算几何</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-16 模拟赛</title>
    <url>/26627/</url>
    <content><![CDATA[<p>我讨厌线段树。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-文件改名"><a href="#T1-文件改名" class="headerlink" title="T1 文件改名"></a>T1 文件改名</h2><p><a href="files.cpp" download="files.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>字符串哈希预处理，用一个 <code>std::map</code> 来存每个文件的原名字（其实离散化更快<del>（虽然就快了每点 15 ms ……</del>），然后找点、链、环，每个点贡献为零，每条链贡献为这条链的点数，每个环的贡献为这个环的点数加一，然后结束。</p>
<h2 id="T2-HAOI2012-高速公路"><a href="#T2-HAOI2012-高速公路" class="headerlink" title="T2 [HAOI2012] 高速公路"></a>T2 [HAOI2012] 高速公路</h2><p><a href="road.cpp" download="road.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P2221">洛谷 Luogu2221</a>，大视野在线评测 BZOJ2752</p>
<p>一道恶心线段树，写了 20 分暴力，太恶心了。</p>
<p>思路是先推出每个区间的期望值公式，然后想如何用线段树维护。</p>
<p>（口胡：）</p>
<p>期望值公式很简单，分母可以直接用区间长度算出来，分子每个点权值由两边向中间递增，线段树想两个字区间合并时如何改就行了<del>（就是不会）</del>。</p>
<h2 id="T3-矩形"><a href="#T3-矩形" class="headerlink" title="T3 矩形"></a>T3 矩形</h2><p><a href="horizon.cpp" download="horizon.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>弱化版扫描线，写了个空间复杂度假的算法，时间复杂度是均摊 $\Theta(MAX\_LONG \log n)$。</p>
<h2 id="T4-SCOI2016-萌萌哒"><a href="#T4-SCOI2016-萌萌哒" class="headerlink" title="T4 [SCOI2016] 萌萌哒"></a>T4 [SCOI2016] 萌萌哒</h2><p><a href="number.cpp" download="number.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P3295">洛谷 Luogu3295</a>，大视野在线评测 BZOJ4569</p>
<p>原题，忘了倍增挂了。</p>
<p>思路是每个区间每个点用并查集合并到一个区间，统计最后剩几个区间就好，要倍增优化，剩 $n$ 个区间时，答案为 $9 \times 10^{n - 1} \bmod 1^9 + 7$ 。</p>
<h1 id="合计-100-20-50-30-200"><a href="#合计-100-20-50-30-200" class="headerlink" title="合计 $100 + 20 + 50 + 30 = 200$"></a>合计 $100 + 20 + 50 + 30 = 200$</h1><p>由于博客挂了会所以等了很久更新（虽说就一天）。</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>并查集</tag>
        <tag>搜索</tag>
        <tag>字符串哈希</tag>
        <tag>扫描线</tag>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-23 模拟赛</title>
    <url>/40982/</url>
    <content><![CDATA[<p>我讨厌线段树 * 2 。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-RP堆"><a href="#T1-RP堆" class="headerlink" title="T1 RP堆"></a>T1 RP堆</h2><p><a href="rp.cpp" download="rp.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>将两个数转换为二进制，其父节点即二进制下最长公共前缀，每个点的深度为二进制位数，答案为深度相减。</p>
<h2 id="T2-线段树"><a href="#T2-线段树" class="headerlink" title="T2 线段树"></a>T2 线段树</h2><p><a href="seg.cpp" download="seg.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>正解是 $\Theta(\log n)$ 计算区间，然后直接算出答案，写了个 $\rm \color{black}MLE$ 算法。</p>
<h2 id="T3-宇宙图书馆"><a href="#T3-宇宙图书馆" class="headerlink" title="T3 宇宙图书馆"></a>T3 宇宙图书馆</h2><p><a href="lib.cpp" download="lib.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>裸的值域线段树，没写出来…………………………………………</p>
<h2 id="T4-最优背包"><a href="#T4-最优背包" class="headerlink" title="T4 最优背包"></a>T4 最优背包</h2><p><a href="bag.cpp" download="bag.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>我……</p>
<p>奇怪的<a href="bag88.cpp" download="bag88.cpp">代码</a>有 88 分，而<a href="bag100.cpp" download="bag100.cpp">这个</a>有 100 分……</p>
<h1 id="合计-100-60-25-0-185"><a href="#合计-100-60-25-0-185" class="headerlink" title="合计 $100 + 60 + 25 + 0 = 185$"></a>合计 $100 + 60 + 25 + 0 = 185$</h1><p>死了……</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>二进制</tag>
        <tag>最近公共祖先, LCA</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-30 模拟赛</title>
    <url>/10212/</url>
    <content><![CDATA[<p>……</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-JSOI2010-连通数"><a href="#T1-JSOI2010-连通数" class="headerlink" title="T1 [JSOI2010] 连通数"></a>T1 [JSOI2010] 连通数</h2><p><a href="connect.cpp" download="connect.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P4306">洛谷 Luogu4306</a>，大视野在线评测 BZOJ2208</p>
<p>做法一：先缩点，再反向拓扑排序；</p>
<p>做法二： <code>std::bitset</code> 直接合并。</p>
<p>考试的时候只想到了反向拓扑，没想到缩点，<del>可能是因为不会吧（</del></p>
<h2 id="T2-K优先队列"><a href="#T2-K优先队列" class="headerlink" title="T2 K优先队列"></a>T2 K优先队列</h2><p><a href="queue.cpp" download="queue.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>对顶堆……，用 <code>std::vector</code> 写了个 70 分的。</p>
<h2 id="T3-阅读理解"><a href="#T3-阅读理解" class="headerlink" title="T3 阅读理解"></a>T3 阅读理解</h2><p><a href="reading.cpp" download="reading.cpp">考场代码</a></p>
<p>提交地址：<a href="http://192.168.0.111:1926/problem/84">SIGSEGV OJ SSOJ84</a></p>
<p>超级恶心，动态开点线段树存质因数查询。</p>
<h2 id="T4-简单计数问题"><a href="#T4-简单计数问题" class="headerlink" title="T4 简单计数问题"></a>T4 简单计数问题</h2><p><a href="reading.cpp" download="reading.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>分块。</p>
<h1 id="合计-40-10-70-50-170"><a href="#合计-40-10-70-50-170" class="headerlink" title="合计 $40 + 10 + 70 + 50 = 170$"></a>合计 $40 + 10 + 70 + 50 = 170$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>对顶堆</tag>
        <tag>平衡树</tag>
        <tag>可持久化线段树</tag>
        <tag>缩点</tag>
        <tag>拓扑排序</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-06-06 模拟赛</title>
    <url>/43261/</url>
    <content><![CDATA[<p>数组开小了，白送 $40$ 分。</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-天猫的小鱼"><a href="#T1-天猫的小鱼" class="headerlink" title="T1 天猫的小鱼"></a>T1 天猫的小鱼</h2><p><a href="catfish.cpp" download="catfish.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>二进制扫一遍，当作三进制做。</p>
<h2 id="T2-【模板】高斯消元法"><a href="#T2-【模板】高斯消元法" class="headerlink" title="T2 【模板】高斯消元法"></a>T2 【模板】高斯消元法</h2><p><a href="shopping.cpp" download="shopping.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P3389">洛谷 Luogu3389</a></p>
<p>高斯消元模版。</p>
<h2 id="T3-Ural1042-Central-Heating"><a href="#T3-Ural1042-Central-Heating" class="headerlink" title="T3 [Ural1042] Central Heating"></a>T3 [Ural1042] Central Heating</h2><p><a href="heat.cpp" download="heat.cpp">考场代码</a></p>
<p>提交地址：<a href="http://poj.org/problem?id=2345">POJ POJ2345</a>，<a href="https://acm.timus.ru/problem.aspx?space=1&num=1042">TIMUS Ural1042</a></p>
<p>高斯消元模版，把减号改成异或即可。</p>
<h2 id="T4-SDOI2009-HH去散步"><a href="#T4-SDOI2009-HH去散步" class="headerlink" title="T4 [SDOI2009] HH去散步"></a>T4 [SDOI2009] HH去散步</h2><p><a href="running.cpp" download="runnnig.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P2151">洛谷 Luogu2151</a>，大视野在线评测 BZOJ1875</p>
<p>原题，点边互换。</p>
<p>数组开小了，白送 $40$ 分。</p>
<h1 id="合计-100-100-100-60-360"><a href="#合计-100-100-100-60-360" class="headerlink" title="合计 $100 + 100 + 100 + 60 = 360$"></a>合计 $100 + 100 + 100 + 60 = 360$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>高斯消元</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-06-09 模拟赛</title>
    <url>/49246/</url>
    <content><![CDATA[<p>头疼……</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="A-食堂承包"><a href="#A-食堂承包" class="headerlink" title="A 食堂承包"></a>A 食堂承包</h2><p><a href="a.cpp" download="a.cpp">考场代码</a></p>
<p>提交地址：<a href="https://sjzezoj.com/problem/58">S2 Online Judge S2OJ76</a></p>
<p>先二分，然后贪心剪枝暴力深搜。</p>
<p>啥也买不了的人扔掉，没人买的聊的扔掉，先买卖贵的、富的。</p>
<h2 id="B-Usaco2007-Demo-Cow-Acrobats"><a href="#B-Usaco2007-Demo-Cow-Acrobats" class="headerlink" title="B [Usaco2007 Demo] Cow Acrobats"></a>B [Usaco2007 Demo] Cow Acrobats</h2><p><a href="b.cpp" download="b.cpp">考场代码</a></p>
<p>提交地址：<a href="https://sjzezoj.com/problem/399">S2 Online Judge S2OJ399</a>，大视野在线评测 BZOJ1629</p>
<p>原题，类似于[NOIP2012 提高组]国王游戏，微扰证明，按力量加重量小到大排最优。</p>
<h2 id="C-盖房子"><a href="#C-盖房子" class="headerlink" title="C 盖房子"></a>C 盖房子</h2><p><a href="c.cpp" download="c.cpp">考场代码</a></p>
<p>提交地址：<a href="https://sjzezoj.com/problem/400">S2 Online Judge S2OJ400</a></p>
<p>二分答案， $\ge mid$ 的当作 $1$ ，否则当作 $0$ 然后 check 即可， check 时先存当前行的有哪些位置是 $1$ 只有判定正确直接退出，不会重复扫。</p>
<h2 id="D-矿脉"><a href="#D-矿脉" class="headerlink" title="D 矿脉"></a>D 矿脉</h2><p><a href="d.cpp" download="d.cpp">考场代码</a></p>
<p>提交地址：<a href="https://sjzezoj.com/problem/401">S2 Online Judge S2OJ401</a></p>
<p>正解是 $\Theta(n^4)$ 预处理维护前缀和处理以某点为左上角的子和，然后转移处理答案， $\Theta(1)$ 查询，但是此题过于水，比暴力还慢的 $\Theta(n^4 + qn^4)$ 都过了。</p>
<h1 id="合计-10-100-100-100-310"><a href="#合计-10-100-100-100-310" class="headerlink" title="合计 $10 + 100 + 100 + 100 = 310$"></a>合计 $10 + 100 + 100 + 100 = 310$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>矩阵</tag>
        <tag>二分答案</tag>
        <tag>深度优先搜索, dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-06-27 模拟赛</title>
    <url>/37632/</url>
    <content><![CDATA[<p>qwq.</p>
<span id="more"></span>

<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-数学题"><a href="#T1-数学题" class="headerlink" title="T1 数学题"></a>T1 数学题</h2><p><a href="count.cpp" download="count.cpp">考场代码</a></p>
<p>提交地址：无</p>
<p>裸的完全背包，却调了一个小时……</p>
<h2 id="T2-APIO2010-特别行动队"><a href="#T2-APIO2010-特别行动队" class="headerlink" title="T2 [APIO2010] 特别行动队"></a>T2 [APIO2010] 特别行动队</h2><p><a href="commando.cpp" download="commando.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P3628">洛谷 Luogu3628</a>，大视野在线评测 BZOJ1911</p>
<p>原题，斜率优化，单调队列存凸壳即可，暴力 DP 也有部分分。</p>
<h2 id="T3-取数游戏"><a href="#T3-取数游戏" class="headerlink" title="T3 取数游戏"></a>T3 取数游戏</h2><p><a href="num.cpp" download="num.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P1123">洛谷 Luogu1123</a></p>
<p>可以直接爆搜，剪枝就是可行性剪枝（其实不减都能过），或者状压DP也行。</p>
<h2 id="T4-序列"><a href="#T4-序列" class="headerlink" title="T4 序列"></a>T4 序列</h2><p><a href="sequence.txt">考场代码</a></p>
<p>提交地址：无</p>
<p><del>可以观察出答案是等差数列</del>，根本没看出来，暴力也没写出来……</p>
<h1 id="合计-100-100-100-0-300"><a href="#合计-100-100-100-0-300" class="headerlink" title="合计 $100 + 100 + 100 + 0 = 300$"></a>合计 $100 + 100 + 100 + 0 = 300$</h1>]]></content>
      <categories>
        <category>日志</category>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>动态规划, DP</tag>
        <tag>深度优先搜索, dfs</tag>
        <tag>剪枝</tag>
        <tag>背包</tag>
        <tag>完全背包</tag>
        <tag>状态压缩动态规划, 状压DP</tag>
        <tag>斜率优化动态规划, 斜率优化DP</tag>
        <tag>斐波那契数列</tag>
        <tag>可行性剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展中国剩余定理, Extended Chinese remainder theorem, extcrt</title>
    <url>/39570/</url>
    <content><![CDATA[<p>快去试试扩展扩展中国剩余定理。</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">extcrt</span><span class="params">(T n, T *b, T *a)</span> </span>&#123;</span><br><span class="line">    T ans = a[<span class="number">1</span>], M = b[<span class="number">1</span>], x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> T i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        T B = ((a[i] - ans) % b[i] + b[i]) % b[i];</span><br><span class="line">        T GCD = extgcd&lt;T&gt;(M, b[i], x, y);</span><br><span class="line">        x = qmul&lt;T&gt;(x, B / GCD, b[i]);</span><br><span class="line">        ans += M * x;</span><br><span class="line">        M *= b[i] / GCD;</span><br><span class="line">        ans = (ans + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>同余</tag>
        <tag>扩展欧几里得算法, extgcd</tag>
        <tag>扩展中国剩余定理, extcrt</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里得算法, Extended Euclidean algorithm, extgcd</title>
    <url>/13399/</url>
    <content><![CDATA[<p>扩展欧几里得，用于解同余方程。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">维基百科</a>，<a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">百度百科</a>，<a href="https://oi-wiki.org/math/gcd/#_7">OI Wiki</a></p>
<p>在求得 $(a, b)$ 的同时，能找到整数 $x, y$ （其中一个很可能是负数），使它们满足裴蜀定理：</p>
<p>$$ax + by = (a, b)$$</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>$\Theta(\log n)$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">extgcd</span><span class="params">(T a, T b, T &amp;x, T &amp;y)</span> </span>&#123;</span><br><span class="line">    T d = a;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        d = extgcd&lt;T&gt;(b, a % b, y, x);</span><br><span class="line">        y -= (a / b) * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>裴蜀定理</tag>
        <tag>扩展欧几里得算法, extgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>快速乘</title>
    <url>/21676/</url>
    <content><![CDATA[<p><del>快速</del>龟速乘。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>由于在乘模时可能在模之前就溢出了，所以我们可以使用类似于快速幂的思想，将乘法分解来算。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>$\Theta(\log n)$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">qmul</span><span class="params">(T x, T y, T mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    T ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ((ret % mod) + (x % mod)) % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = ((x % mod) + (x % mod)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>快速乘</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧拉定理（数论）, Extend Euler&#39;s theorem(Number Theory)</title>
    <url>/26296/</url>
    <content><![CDATA[<p>数竞生：信竞咋啥都扩展？</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>$$a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},\,&amp;(a,\,p)=1\\ a^b,&amp;(a,\,p)\ne1,\,b&lt;\varphi(p)\\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;(a,\,p)\ne1,\,b\ge\varphi(p) \end{cases} \pmod p$$</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>扩展欧拉定理（数论）</tag>
      </tags>
  </entry>
  <entry>
    <title>费马小定理, Fermat&#39;s little theorem</title>
    <url>/19332/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/blog/AG-Liangsheng/">$\rm \color{red}¶\color{black}凉笙$</a> ：</p>
<blockquote>
<p>费小马定理是啥？</p>
</blockquote>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="形式一"><a href="#形式一" class="headerlink" title="形式一"></a>形式一</h2><p>若 $p$ 为质数，且  $a$ 与 $p$ 互质（即 $(a, p) = 1$ ），则有</p>
<p>$$a^{p - 1} \equiv 1 \pmod{p}$$</p>
<h2 id="形式二"><a href="#形式二" class="headerlink" title="形式二"></a>形式二</h2><p>若 $p$ 为质数，对于任意 $a$ 有</p>
<p>$$a^p \equiv a \pmod{p}$$</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/6782/</url>
    <content><![CDATA[<p>经典二进制分治。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>利用二进制分治思想，有 $a^{b+c} = a^b \cdot a^c,,,a^{2b} = a^b \cdot a^b = (a^b)^2$ 可以使我们减少大量的运算，而在 $\Theta(\log n)$ 的时间内求出幂。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>$\Theta(\log n)$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">qpowi</span><span class="params">(T b, T p)</span> </span>&#123;</span><br><span class="line">    T s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) s *= b;</span><br><span class="line">        b *= b;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">qpowimod</span><span class="params">(T b, T p, T mod)</span> </span>&#123;</span><br><span class="line">    T s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) s = s * b % mod;</span><br><span class="line">        b = b * b % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>克努斯-莫里斯-普拉特算法, Knuth-Morris-Pratt Algorithm, KMP</title>
    <url>/53323/</url>
    <content><![CDATA[<p>字符串模式匹配。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://oi-wiki.org/string/kmp/">OIWiki</a></p>
<p>如何找到一个字符串（模式串）在另一个字符串（文本串）中出现了几次？或者说有几个子串和这个字符串一样？并且找到出现位置。</p>
<p>我们可以枚举每一个子串的开头位置，一一去比较，复杂度为 $\Theta(mn)$ ，其中 $n$ 为文本串的长度， $m$ 为模式串的长度。</p>
<p>这样很慢，有没有比较高效的方法？</p>
<p>方法就是 $\rm{KMP}$ 。</p>
<p>$\rm{KMP}$ 算法可以使用 $\Theta(m)$ 的时间对模式串预处理， $\Theta(n)$ 的时间对每个文本串进行匹配。</p>
<p>怎么做到的？</p>
<p>就是在每次失配的时候直接跳跃到下一个可以匹配未失配部分的位置，这样就做到了 $\Theta(n)$ 的时间匹配，而找到下一个位置就是预处理要做的。</p>
<p>证明……不会，至今不懂，<del>直接背就好</del>。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>预处理 $\Theta(m)$ ，匹配 $\Theta(n)$ 。</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm{\color{Green}code}$"></a>$\rm{\color{Green}code}$</h1><h2 id="rm-OI"><a href="#rm-OI" class="headerlink" title="$\rm{OI}$"></a>$\rm{OI}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> next[maxn], len1, len2, ans[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s1[maxn], s2[maxn]; <span class="comment">// s2 为模式串， s1 为文本串</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span> </span>&#123;	 <span class="comment">// 预处理</span></span><br><span class="line">    len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="number">0</span>, t2;</span><br><span class="line">    next[<span class="number">0</span>] = t2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t1 &lt; len2) </span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="number">-1</span> || s2[t1] == s2[t2])</span><br><span class="line">            next[++t1] = ++t2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t2 = next[t2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123; <span class="comment">// 匹配</span></span><br><span class="line">    len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t1 &lt; len1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="number">-1</span> || s1[t1] == s2[t2]) </span><br><span class="line">            t1++, t2++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t2 = next[t2];</span><br><span class="line">        <span class="keyword">if</span> (t2 == len2) &#123;</span><br><span class="line">            ans[++cnt] = t1 - len2 + <span class="number">1</span>;</span><br><span class="line">            t2 = next[t2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>克努斯-莫里斯-普拉特算法, KMP</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>线性求乘法逆元</title>
    <url>/28476/</url>
    <content><![CDATA[<p><a href="https://blog.i207m.top/">$\rm \color{black}i\color{red}207M$</a> ：</p>
<blockquote>
<p>你知道吗？求逆元有五种方法。</p>
</blockquote>
<span id="more"></span>

<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">  inline void get_inverse1(T n, T p, T *inverse);</span></span><br><span class="line"><span class="comment">  线性求 n 以下关于模 p 的逆元</span></span><br><span class="line"><span class="comment">  T 必须为整型类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_inverse1</span><span class="params">(T n, T p, T *inverse)</span> </span>&#123;</span><br><span class="line">    inverse[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        inverse[i] = p - p / i * inverse[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><h2 id="color-Green-code-1"><a href="#color-Green-code-1" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">  inline void get_inverse2(T n, T p, T *a, T *inverse);</span></span><br><span class="line"><span class="comment">  线性求任意 n 个数关于模 p 的逆元</span></span><br><span class="line"><span class="comment">  T 必须为整型类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_inverse2</span><span class="params">(T n, T p, T *a, T *inverse)</span> </span>&#123;</span><br><span class="line">    T *preprod, *invprod;</span><br><span class="line">    preprod = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(n + <span class="number">5</span>);</span><br><span class="line">    invprod = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(n + <span class="number">5</span>);</span><br><span class="line">    preprod[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) preprod[i] = preprod[i - <span class="number">1</span>] * a[i] % p;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="built_in">extgcd</span>(preprod[n], p, invprod[n], x);</span><br><span class="line">    invprod[n] = (invprod[n] % p + p) % p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) invprod[i] = invprod[i + <span class="number">1</span>] * a[i + <span class="number">1</span>] % p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) inverse[i] = invprod[i] * preprod[i - <span class="number">1</span>] % p;</span><br><span class="line">    <span class="keyword">delete</span>[] preprod;</span><br><span class="line">    <span class="keyword">delete</span>[] invprod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>筛法</tag>
        <tag>线性筛</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>卢卡斯定理, Lucas&#39; theorem , lucas</title>
    <url>/30428/</url>
    <content><![CDATA[<p><del>简介，不知道写啥了。</del></p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>对于质数 $p$ ，有：</p>
<p>$$\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p$$</p>
<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">lucas</span><span class="params">(T n, T m, T p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n % p, m % p, p) * <span class="built_in">lucas</span>(n / p, m / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>卢卡斯定理, lucas</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性求欧拉函数</title>
    <url>/58730/</url>
    <content><![CDATA[<p>又一个线性筛。</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(T n, T *phi_table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i) phi_table[i] = <span class="number">0</span>;</span><br><span class="line">    phi_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!phi_table[i])</span><br><span class="line">            <span class="keyword">for</span> (T j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi_table[j]) phi_table[j] = j;</span><br><span class="line">                phi_table[j] = phi_table[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>欧拉函数</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>映射与函数</title>
    <url>/13431/</url>
    <content><![CDATA[<p>上次碰微积分是在初三寒假？</p>
<p>基本快忘光了……</p>
<span id="more"></span>

<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>微积分研究函数，而函数又是映射的一种，我们先来学映射。</p>
<h2 id="概念与定义"><a href="#概念与定义" class="headerlink" title="概念与定义"></a>概念与定义</h2><p>相信大家都学过 <code>std::map</code> 吧，映射的英文就是 map。</p>
<p>简单来说，映射就像 <code>std::map</code> 一样，可以将一个元素对应到另一个元素，比如每个身份证号能对应到一个人名。</p>
<p>更严谨点说应该是将一个集合中的元素对应到另一个集合中的元素，而且原集合的元素必须唯一对应一个新集合的元素，但是反过来却不必。还拿身份证的例子举例，一个身份证号一定能对应到一个人名，而因为可以重名，一个人名却可以对应到好几个身份证号。</p>
<p>我们大概清楚了什么是映射，现在看看映射的具体定义：</p>
<p>设 $X$､$Y$ 是两个非空集合,如果存在一个法则 $f$,使得对 $X$ 中每个元素 $x$,按法则 $f$,在 $Y$ 中有唯一确定的元素 $y$ 与之对应,那么称 $f$ 为从 $X$ 到 $Y$ 的映射,记作</p>
<p>$$f: X \rightarrow Y$$,</p>
<p>其中 $y$ 称为元素 $x$(在映射 $f$ 下)的像,并记作 $f(x)$,即</p>
<p>$$y = f(x)$$,</p>
<p>而元素 $x$ 称为元素 $y$ (在映射 $f$ 下)的一个原像;集合 $X$ 称为映射 $f$ 的定义域,记作 $D_f$,即 $D_f = X$;$X$ 中的所有元素的像所组成的集合称为映射 $f$ 的值域,记作 $R_f$ 或 $f(X)$,即</p>
<p>$$R_f = f(X) = {f(x) | x \in X}$$.</p>
<p>再次强调 $x$ 要对应唯一的 $y$，而 $y$ 不一定对应唯一的 $x$。</p>
<h2 id="满射、单射与双射"><a href="#满射、单射与双射" class="headerlink" title="满射、单射与双射"></a>满射、单射与双射</h2><p>我们在定义中注意到 $R_f$ 是 $Y$ 的子集，当 $Y$ 中任意一个元素都是 $X$ 中某个元素的像，即 $R_f = Y$，我们称 $f$ 为从 $X$ 到 $Y$ 上的满射；</p>
<p>若 $\forall x_1, x_2 \in X$ 且 $x_1 \neq x_2$，有 $f(x_1) \neq f(x_2)$，则称 $f$ 为从 $X$ 到 $Y$ 上的单射；</p>
<p>若 $f$ 既是单射又是满射则称之为双射。</p>
<h2 id="映射的不同名称"><a href="#映射的不同名称" class="headerlink" title="映射的不同名称"></a>映射的不同名称</h2><p>在不同的数学分支中映射又有不同的名称，如：</p>
<ul>
<li>从非空数集 $X$ 到数集 $Y$ 的映射叫泛函；</li>
<li>从非空集 $X$ 到它自身的映射叫变换；</li>
<li>从实数集 $X$ 到实数集 $Y$ 的映射叫函数。</li>
</ul>
<h2 id="逆映射"><a href="#逆映射" class="headerlink" title="逆映射"></a>逆映射</h2><p>对一个 $f$,若 $f$ 是从 $X$ 到 $Y$ 的单射,那我们就可以定义一个新的映射 $g$,即:</p>
<p>$$g: R_f \rightarrow X$$,</p>
<p>对于每一个 $y \in R_f$,规定 $g(y) = x$,其中 $f(x) = y$,则 $g$ 为 $f$ 的逆映射,记作 $f^{-1}$.</p>
<p>例如：</p>
<p>$$f(x) = \sin x, (x \in [-\frac{\pi}{2}, -\frac{\pi}{2}])$$</p>
<p>的反函数为</p>
<p>$$f^{-1}(x) = \arcsin x, x \in [-1, 1]$，</p>
<p>$$f(x) = \exp x$$</p>
<p>的反函数为</p>
<p>$$f^{-1}(x) = \ln x$$</p>
<h2 id="复合映射"><a href="#复合映射" class="headerlink" title="复合映射"></a>复合映射</h2><p>若有两个映射</p>
<p>$$g: X \rightarrow Y_1, f: Y_2 \rightarrow Z, Y_1 \sub Y_2$$,</p>
<p>则由 $g$ 和 $f$ 可以定义处一个从 $X$ 到 $Z$ 的映射,称为映射 $g$ 和 $f$ 的复合映射,记作 $f \circ g$,即</p>
<p>$$f \circ g: X \to Z, (f \circ g)(x) = f[g(x)], x \in X$$.</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>数学分析</category>
      </categories>
      <tags>
        <tag>映射</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>标记永久化线段树</title>
    <url>/54665/</url>
    <content><![CDATA[<p><a href="https://kamome.moe/">$\rm\color{red}S\color{black}iunaus$ ($\rm Zhang\_RQ$)</a> ：</p>
<blockquote>
<p>标记永久化线段树不需要 $\rm pushdown$ 。</p>
</blockquote>
<p>……</p>
<span id="more"></span>

<h1 id="color-Green-code-oi"><a href="#color-Green-code-oi" class="headerlink" title="$\color{Green}code - oi$"></a>$\color{Green}code - oi$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll v;</span><br><span class="line">    ll add;</span><br><span class="line">    <span class="built_in">node</span>() : <span class="built_in">add</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; st[p].v = st[<span class="built_in">ls</span>(p)].v + st[<span class="built_in">rs</span>(p)].v; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        st[p].v = a[l];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, m);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; cl || cr &lt; nl) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cl &lt;= nl &amp;&amp; nr &lt;= cr) &#123;</span><br><span class="line">        st[p].v = st[p].v + k * (nr - nl + <span class="number">1</span>);</span><br><span class="line">        st[p].add = st[p].add + k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st[p].v += k * (<span class="built_in">min</span>(nr, cr) - <span class="built_in">max</span>(nl, cl) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(nl, nr);</span><br><span class="line">    <span class="built_in">plus</span>(<span class="built_in">ls</span>(p), nl, m, cl, cr, k);</span><br><span class="line">    <span class="built_in">plus</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, nr, cl, cr, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, ll tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; ql || qr &lt; nl) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= nl &amp;&amp; nr &lt;= qr) <span class="keyword">return</span> st[p].v + tag * (nr - nl + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(nl, nr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), nl, m, ql, qr, tag + st[p].add) +</span><br><span class="line">           <span class="built_in">query</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, nr, ql, qr, tag + st[p].add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="color-Green-code-poject"><a href="#color-Green-code-poject" class="headerlink" title="$\color{Green}code - poject$"></a>$\color{Green}code - poject$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segment_tree</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _ls(<span class="keyword">int</span> f) &#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _rs(<span class="keyword">int</span> f) &#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _mid(<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _max(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123; <span class="keyword">return</span> (a &gt; b) ? a : b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _min(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123; <span class="keyword">return</span> (a &lt; b) ? a : b; &#125;</span><br><span class="line">    T *_a;</span><br><span class="line">    T _n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        T v;</span><br><span class="line">        T add;</span><br><span class="line">        <span class="built_in">node</span>() : <span class="built_in">add</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125; * _st;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; _st[p].v = _st[_ls(p)].v + _st[_rs(p)].v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            _st[p].v = _a[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = _mid(l, r);</span><br><span class="line">            <span class="built_in">build</span>(_ls(p), l, m);</span><br><span class="line">            <span class="built_in">build</span>(_rs(p), m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">push_up</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _plus(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, T k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; cl || cr &lt; nl) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= nl &amp;&amp; nr &lt;= cr) &#123;</span><br><span class="line">            _st[p].v += k * (nr - nl + <span class="number">1</span>);</span><br><span class="line">            _st[p].add += k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _st[p].v += k * (_min(nr, cr) - _max(nl, cl) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = _mid(nl, nr);</span><br><span class="line">        _plus(_ls(p), nl, m, cl, cr, k);</span><br><span class="line">        _plus(_rs(p), m + <span class="number">1</span>, nr, cl, cr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    T _query(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, T tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; ql || qr &lt; nl) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= nl &amp;&amp; nr &lt;= qr) <span class="keyword">return</span> _st[p].v + tag * (nr - nl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = _mid(nl, nr);</span><br><span class="line">        <span class="keyword">return</span> _query(_ls(p), nl, m, ql, qr, tag + _st[p].add) +</span><br><span class="line">               _query(_rs(p), m + <span class="number">1</span>, nr, ql, qr, tag + _st[p].add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">segment_tree</span>(T n, T *a) : _n(n), _a(a) &#123;</span><br><span class="line">        _st = <span class="keyword">new</span> node[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, _n);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">segment_tree</span>() &#123; <span class="keyword">delete</span>[] _st; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T k)</span> </span>&#123; _plus(<span class="number">1</span>, <span class="number">1</span>, _n, l, r, k); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> _query(<span class="number">1</span>, <span class="number">1</span>, _n, l, r, <span class="number">0</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>区间最值, RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元, Multiplicative Inverse</title>
    <url>/24044/</url>
    <content><![CDATA[<p><a href="https://blog.i207m.top/">$\rm \color{black}i\color{red}207M$</a> ：</p>
<blockquote>
<p>你知道吗？求逆元有五种方法。</p>
</blockquote>
<span id="more"></span>

<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>使用费马小定理，这种方法要求 $p$ 是质数。</p>
<p>由</p>
<p>$$a \times a^{p - 2} \equiv 1 \pmod{p}$$</p>
<p>可得</p>
<p>$$a^{-1} = a^{p - 2}$$</p>
<p>然后就可以使用快速幂求逆元。</p>
<p>如下：</p>
<h2 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">inverse_fermat</span><span class="params">(T n, T p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qipow</span>(n, p - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h1><p>扩展欧几里得算法。</p>
<p>$$ax \equiv 1 \pmod{b}$$</p>
<p>$x$ 即为 $a$ 在模 $b$ 意义下的逆元。</p>
<p>如下：</p>
<h2 id="color-Green-code-1"><a href="#color-Green-code-1" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">inverse_extgcd</span><span class="params">(T n, T p)</span> </span>&#123;</span><br><span class="line">    T x, y;</span><br><span class="line">    <span class="built_in">extgcd</span>(n, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIO2021 #1</title>
    <url>/60602/</url>
    <content><![CDATA[<p>裂开，太难了，这次比赛深刻的让我认识到了我菜的本质。</p>
<span id="more"></span>

<h1 id="游记"><a href="#游记" class="headerlink" title="游记"></a>游记</h1><p>没有，因为是线上。</p>
<h1 id="题目-amp-简易介绍"><a href="#题目-amp-简易介绍" class="headerlink" title="题目 &amp; 简易介绍"></a>题目 &amp; 简易介绍</h1><h2 id="T1-NOIO2021-1-提高组-愤怒的小N"><a href="#T1-NOIO2021-1-提高组-愤怒的小N" class="headerlink" title="T1 [NOIO2021 #1 提高组] 愤怒的小N"></a>T1 [NOIO2021 #1 提高组] 愤怒的小N</h2><p><a href="angry.cpp" download="angry.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7468">洛谷 Luogu7468</a></p>
<p>数学， 不会，打了个暴力，估计也没多少分，有 10 pts，看了看题解，还是直接放弃为好。</p>
<h2 id="T2-NOIO2021-1-提高组-积木小赛"><a href="#T2-NOIO2021-1-提高组-积木小赛" class="headerlink" title="T2 [NOIO2021 #1 提高组] 积木小赛"></a>T2 [NOIO2021 #1 提高组] 积木小赛</h2><p><a href="block.cpp" download="block.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7469">洛谷 Luogu7469</a></p>
<p>字符串匹配， 匹配两个字符串的子串和子序列，写了个哈希，有 60 pts，正解是贪心。</p>
<h2 id="T3-NOIO2021-1-提高组-岛屿探险"><a href="#T3-NOIO2021-1-提高组-岛屿探险" class="headerlink" title="T3 [NOIO2021 #1 提高组] 岛屿探险"></a>T3 [NOIO2021 #1 提高组] 岛屿探险</h2><p><a href="island.cpp" download="island.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7470">洛谷 Luogu7470</a></p>
<p>区间异或和奇怪的东西，不会，打暴力， 20 pts，正解 CDQ 分治。</p>
<h2 id="提高合计"><a href="#提高合计" class="headerlink" title="提高合计"></a>提高合计</h2><p>合计 $10 + 60 + 20 = 80$ ，压线前 $25%$ 。</p>
<h2 id="T1-NOIO2021-1-入门组-切蛋糕"><a href="#T1-NOIO2021-1-入门组-切蛋糕" class="headerlink" title="T1 [NOIO2021 #1 入门组] 切蛋糕"></a>T1 [NOIO2021 #1 入门组] 切蛋糕</h2><p><a href="cake.cpp" download="cake.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7471">洛谷 Luogu7471</a></p>
<p>特判的水题， AC。</p>
<h2 id="T2-NOIO2021-1-入门组-吃豆人"><a href="#T2-NOIO2021-1-入门组-吃豆人" class="headerlink" title="T2 [NOIO2021 #1 入门组] 吃豆人"></a>T2 [NOIO2021 #1 入门组] 吃豆人</h2><p><a href="pacman.cpp" download="pacman.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7472">洛谷 Luogu7472</a></p>
<p>写了特判 30 pts，正解暴力……不过没时间写了，毕竟只写了一个小时。</p>
<h2 id="T3-NOIO2021-1-入门组-重力球"><a href="#T3-NOIO2021-1-入门组-重力球" class="headerlink" title="T3 [NOIO2021 #1 入门组] 重力球"></a>T3 [NOIO2021 #1 入门组] 重力球</h2><p><a href="ball.cpp" download="ball.cpp">考场代码</a></p>
<p>提交地址：<a href="https://www.luogu.com.cn/problem/P7473">洛谷 Luogu7473</a></p>
<p>写的暴力，没分，正解 BFS + 最短路？</p>
<h2 id="普及合计"><a href="#普及合计" class="headerlink" title="普及合计"></a>普及合计</h2><p>合计 $100 + 30 + 0 = 130$ ，前 $25%$ 。</p>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>€€￡ 一直崩服务器，圈的钱都去哪里了？</p>
<h1 id="关于2031年这件事"><a href="#关于2031年这件事" class="headerlink" title="关于2031年这件事"></a>关于2031年这件事</h1><p><img src="2031.png" alt="2031"></p>
<p>就离谱。</p>
]]></content>
      <categories>
        <category>游记</category>
        <category>NOIO</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】莫队集合</title>
    <url>/10510/</url>
    <content><![CDATA[<p>原标题：<a href="https://lawrencesivan.github.io/2021/04/22/%E8%8E%AB%E9%98%9F%E5%85%A8%E5%AE%B6%E6%A1%B6/">莫队全家桶</a></p>
<p>作者： <a href="https://lawrencesivan.github.io/">$\rm \color{black}L\color{red}awrenceSivan$</a></p>
<p>原文协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际</a></p>
<p>略有修改。</p>
<p><strong>今天学习了莫队</strong><br><del>实在是太有魅力了</del></p>
<p>来写个学习笔记</p>
<span id="more"></span>

<p>【XYY1411】：<a href="https://www.zhihu.com/question/24201454">莫队是啥？</a></p>
<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h2 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h2><h3 id="莫队讲解"><a href="#莫队讲解" class="headerlink" title="莫队讲解"></a>莫队讲解</h3><h4 id="一，什么是莫队"><a href="#一，什么是莫队" class="headerlink" title="一，什么是莫队"></a>一，什么是莫队</h4><p>莫队其实就是一种优雅的暴力，它十分玄学巧妙地将分块和暴力结合在了一起，主要用来处理离线区间查询等问题。</p>
<p>由于莫队算法是由莫涛队长提出的，因此我们称这种算法为莫队。</p>
<h4 id="二，莫队原理"><a href="#二，莫队原理" class="headerlink" title="二，莫队原理"></a>二，莫队原理</h4><p>大概说一下，莫队就是对询问进行排序，然后通过左右端点的移动来维护区间信息。</p>
<p><strong>那显而易见，莫队是离线算法</strong></p>
<p>当然莫队还有一些神奇的拓展：</p>
<p>带修莫队，回滚莫队等等（等我学会了再来补博客</p>
<h4 id="三，莫队的操作过程"><a href="#三，莫队的操作过程" class="headerlink" title="三，莫队的操作过程"></a>三，莫队的操作过程</h4><p>1，对于多段区间的询问，先将询问离线存储下来，然后再从左到右扫一遍，在过程中维护一段区间，就可以得到每个询问的答案。</p>
<p>2，但暴力扫肯定不行，所以在扫的过程中,需要对 $l$ 进行排序，以求能够在移动次数最少的情况下,得到所有希望求出的区间。（就是说，我们要调整$m$次询问的顺序，使之有序，这样我们在移动时，就可以不反复来回移动，而单向的用较少的次数就可以进行维护与查询操作。</p>
<p>3，首先对每个区间进行分块操作，再将左端点在一起的区间询问放在一起进行处理，对于每个块处理一遍，那么就可以得到所有询问的答案。（分块的结合就是在这里</p>
<p>最严格的顺序是每个区间求一次曼哈顿距离最小生成树。</p>
<h4 id="四，莫队的代码实现"><a href="#四，莫队的代码实现" class="headerlink" title="四，莫队的代码实现"></a>四，莫队的代码实现</h4><p>自然我们要记录原数组，还要开一个 $cnt$ （用于统计答案个数，还有一个答案数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans[maxn], sum;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], lal = <span class="number">1</span>, lar = <span class="number">0</span>;  <span class="comment">// lal lar分别是上一次的左右端点</span></span><br></pre></td></tr></table></figure>

<p>按照顺序如何处理呢？</p>
<p>把 $[1,n]$ 分成$ \sqrt n$ 块。</p>
<p>还有一种奇妙而玄学的分法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">block = n / <span class="built_in">sqrt</span>(m * <span class="number">2</span> / <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这样会更快一些；</p>
<p>我们先把这些区间按照左端点 $l$ 所在的块从左往右排序</p>
<p>再把l所在块相同的区间按 $r$ 从小到大排序</p>
<p>结构体数组存储查询的区间以及下标</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;  <span class="comment">// l是左端点，r是右端点，id是下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (belong[l] == belong[a.l]) ? r &lt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];  <span class="comment">// mo captain，即莫队</span></span><br></pre></td></tr></table></figure>

<p>这里再提一种玄学的玩意，名曰：<strong>奇偶优化</strong></p>
<p>按奇偶块排序。这也是比较通用的。如果区间左端点所在块不同，那么就直接按左端点从小到大排；如果相同，奇块按右端点从小到大排，偶块按右端点从大到小排。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> belong[l] ^ belong[a.l] ? belong[l] &lt; belong[a.l]</span><br><span class="line">                                   : ((belong[l] &amp; <span class="number">1</span>) ? r &lt; a.r : r &gt; a.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排好了序自然就要开始进行询问和维护操作了</p>
<p><strong>这里也正是莫队的精髓</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = mocap[i].l, r = mocap[i].r;</span><br><span class="line">    <span class="keyword">while</span> (lal &gt; l) lal--, <span class="built_in">add</span>(a[lal]);</span><br><span class="line">    <span class="keyword">while</span> (lar &lt; r) lar++, <span class="built_in">add</span>(a[lar]);</span><br><span class="line">    <span class="keyword">while</span> (lal &lt; l) <span class="built_in">del</span>(a[lal]), lal++;</span><br><span class="line">    <span class="keyword">while</span> (lar &gt; r) <span class="built_in">del</span>(a[lar]), lar--;</span><br><span class="line">    ans[mocap[i].id] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想象一个区间的移动；</p>
<p>$add$ 和 $del$ 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum += <span class="number">2</span> * cnt[x] + <span class="number">1</span>;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum -= <span class="number">2</span> * cnt[x] - <span class="number">1</span>;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="五，莫队的复杂度证明"><a href="#五，莫队的复杂度证明" class="headerlink" title="五，莫队的复杂度证明"></a>五，莫队的复杂度证明</h4><p>对于区间进行分块那么可以得到 $\sqrt{n}$ 个块,那么对于就存在于 $\sqrt{n}$  个区间,而每次对于每个区间块中的 $l,r$ 的最坏情况是对于每个块都遍历到序列的最右端,共 $n$ 个点.每次移动指针复杂度为 $O(1)$ ,所以整个算法的复杂度 $O (n\sqrt{n})$</p>
<p>（真是太美妙了</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="洛谷-P2709-小B的询问"><a href="#洛谷-P2709-小B的询问" class="headerlink" title="洛谷 P2709 小B的询问"></a><a href="https://www.luogu.com.cn/problem/P2709">洛谷 P2709 小B的询问</a></h4><h5 id="CODE："><a href="#CODE：" class="headerlink" title="CODE："></a>CODE：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, block;</span><br><span class="line">ll ans[maxn], sum;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], lal = <span class="number">1</span>, lar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((l - <span class="number">1</span>) / block == (a.l - <span class="number">1</span>) / block) ? r &lt; a.r</span><br><span class="line">                                                      : l / block &lt; a.l / block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum += <span class="number">2</span> * cnt[x] + <span class="number">1</span>;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum -= <span class="number">2</span> * cnt[x] - <span class="number">1</span>;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    k = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        mocap[i].l = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].r = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = mocap[i].l, r = mocap[i].r;</span><br><span class="line">        <span class="keyword">while</span> (lal &gt; l) lal--, <span class="built_in">add</span>(a[lal]);</span><br><span class="line">        <span class="keyword">while</span> (lar &lt; r) lar++, <span class="built_in">add</span>(a[lar]);</span><br><span class="line">        <span class="keyword">while</span> (lal &lt; l) <span class="built_in">del</span>(a[lal]), lal++;</span><br><span class="line">        <span class="keyword">while</span> (lar &gt; r) <span class="built_in">del</span>(a[lar]), lar--;</span><br><span class="line">        ans[mocap[i].id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="洛谷-P1494-国家集训队-小Z的袜子"><a href="#洛谷-P1494-国家集训队-小Z的袜子" class="headerlink" title="洛谷 P1494 [国家集训队]小Z的袜子"></a><a href="https://www.luogu.com.cn/problem/P1494">洛谷 P1494 [国家集训队]小Z的袜子</a></h4><p>首先我们，我们明确莫队一般来讲是只能搞一个区间内某一些东西的出现次数的，如果让我们去求出概率该怎么办呢？</p>
<p>我们用 $cnt$ 数组来记录区间 $[l,r]$ 内某种颜色的袜子出现的次数.</p>
<p>我们考虑在区间 $[l,r]$ 中取出两个相同颜色 $x$ 的情况有：</p>
<p>$C_{cnt[x]}^2= \dfrac{cnt[x] \times (cnt[x]-1)}{2}$</p>
<p>在区间 $[l,r]$ 中取出两个任意颜色的情况有：</p>
<p>$C_{len}^2= \dfrac{len \times (len-1)}{2}$</p>
<p>于是在区间 $[l,r]$ 中取出两个相同颜色 $x$ 的概率就可以搞得出来了：</p>
<p>$C_{cnt[x]}^2= \dfrac{cnt[x] \times (cnt[x]-1)}{len \times (len-1)}=\dfrac{cnt[x] \times (cnt[x]-1)}{(r-l+1) \times (r-l)}=\dfrac{cnt[x]^2-cnt[x]}{(r-l+1) \times (r-l)}$</p>
<p>于是在区间内抽到两个相同数字的概率就是：</p>
<p>$\sum\limits_{i=1}^n \dfrac{cnt[i]^2-cnt[i]}{(r-l+1) \times (r-l)}= \dfrac{\sum\limits_{i=1}^n cnt[i]^2-cnt[i]}{(r-l+1) \times (r-l)}$</p>
<p>对于区间 $[l,r]$ 我们有</p>
<p>$\sum\limits_{i=1}^n cnt[i]=r-l+1$</p>
<p>所以答案为：</p>
<p>$\dfrac{\sum\limits_{i=1}^n cnt[i]^2-(r-l+1)}{(r-l+1) \times (r-l)}$</p>
<p>最后只需要用 $gcd$ 化简就可以了.</p>
<p>于是我们用 $cnt$ 数组维护平方和.</p>
<h5 id="CODE"><a href="#CODE" class="headerlink" title="CODE:"></a>CODE:</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, a[maxn], ans[maxn], lal = <span class="number">1</span>, lar = <span class="number">0</span>, sum, block, cnt[maxn];</span><br><span class="line"></span><br><span class="line">ll l1[maxn], r1[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((l - <span class="number">1</span>) / block == (a.l - <span class="number">1</span>) / block) ? r &lt; a.r</span><br><span class="line">                                                      : l / block &lt; a.l / block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum -= cnt[x] * (cnt[x] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    sum += cnt[x] * (cnt[x] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sum -= cnt[x] * (cnt[x] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    sum += cnt[x] * (cnt[x] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    block = n / <span class="built_in">sqrt</span>(m * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        mocap[i].l = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].r = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">        l1[i] = mocap[i].l, r1[i] = mocap[i].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = mocap[i].l, r = mocap[i].r;</span><br><span class="line">        <span class="keyword">while</span> (lal &gt; l) lal--, <span class="built_in">add</span>(a[lal]);</span><br><span class="line">        <span class="keyword">while</span> (lar &lt; r) lar++, <span class="built_in">add</span>(a[lar]);</span><br><span class="line">        <span class="keyword">while</span> (lal &lt; l) <span class="built_in">del</span>(a[lal]), lal++;</span><br><span class="line">        <span class="keyword">while</span> (lar &gt; r) <span class="built_in">del</span>(a[lar]), lar--;</span><br><span class="line">        ans[mocap[i].id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        tmp = <span class="built_in">gcd</span>((ll)ans[i], (ll)(r1[i] - l1[i] + <span class="number">1</span>) * (r1[i] - l1[i]) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (l1[i] == r1[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0/1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d/%lld\n&quot;</span>, ans[i] / tmp,</span><br><span class="line">                   (ll)((r1[i] - l1[i] + <span class="number">1</span>) * (r1[i] - l1[i]) / <span class="number">2</span>) / tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><p><a href="https://www.luogu.com.cn/problem/P1903">模板题</a></p>
<p><del>其实这道题在智能推荐里躺了很久了，但是我一直没有打开他，然后还一直大喊lj洛谷为什么没有带修莫队的板子题</del></p>
<p><del>wssb</del></p>
<p>首先我们知道普通的莫队是不能修改的。</p>
<p>因为我们每个询问的答案都是根据上一次询问的答案稍加调整得出来的，于是每一次修改操作就会导致对答案产生了严重的影响。</p>
<p>于是我们想办法消除这种影响。</p>
<p>考虑把查询操作和修改操作分别记录下来。</p>
<p>在记录查询操作的时候，需要增加一个变量来记录离本次查询最近的修改的位置（这种玩意其实类似于 $HH$ 的项链)</p>
<p>然后需要用一个变量记录当前已经进行了几次修改.</p>
<p>对于查询操作，如果上一次改的比本次查询需要改的少，就改过去</p>
<p>反之如果改多了就改回来。</p>
<p>简单来说，就是比较这次与上一次修改的操作次数不一样，我们就暴力的搞成一样的就行了。</p>
<p>关于结构体的改进：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    <span class="title">MOCAP</span> &#123;</span>  <span class="comment">//其实结构体应该开两个，就是说查询和修改都开，但是为了简便，我直接开了一个，一表两用</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pre;  <span class="comment">// l和r分别是查询中的左右端点和更改中的位置以及权值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;  <span class="comment">//改进后的排序</span></span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l]</span><br><span class="line">                   ? (belong[r] == belong[a.r] ? pre &lt; a.pre</span><br><span class="line">                                               : belong[r] &lt; belong[a.r])</span><br><span class="line">                   : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn], modi[maxn];</span><br></pre></td></tr></table></figure>

<p>排序的方法：</p>
<ul>
<li><p>关于左右端点的排序，与原来是一样的。</p>
</li>
<li><p>关于修改的排序，修改位置在前面的就排在前面</p>
</li>
</ul>
<p>之后还有一个问题，就是说虽然是存在修改操作的，但是之后再查询的区间内进行修改对答案才是有影响的。</p>
<p>所以在暴力调整修改的时候保证一下区间端点位置就行了</p>
<p>之后还有一个小细节：在每次修改操作之后，下一次的操作一定是与这步是相反的</p>
<p>也就是改后-&gt;还原-&gt;修改-&gt;还原</p>
<p>所以我们直接交换就行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mocap[x].l &lt;= modi[t].l &amp;&amp; mocap[x].r &gt;= modi[t].l) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[modi[t].l]);</span><br><span class="line">        <span class="built_in">add</span>(modi[t].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[modi[t].l], modi[t].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是最后的操作就是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt; mocap[i].l) l--, <span class="built_in">add</span>(a[l]);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; mocap[i].l) <span class="built_in">del</span>(a[l]), l++;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; mocap[i].r) <span class="built_in">del</span>(a[r]), r--;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; mocap[i].r) r++, <span class="built_in">add</span>(a[r]);</span><br><span class="line">    <span class="keyword">while</span> (t &lt; mocap[i].pre) t++, <span class="built_in">update</span>(i, t);  <span class="comment">//改少了</span></span><br><span class="line">    <span class="keyword">while</span> (t &gt; mocap[i].pre) <span class="built_in">update</span>(i, t), t--;  <span class="comment">//改多了</span></span><br><span class="line">    ans[mocap[i].id] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后优化块长：</p>
<ul>
<li>时间上的优化：将块的大小从 $sqrt(n)$ 改为 $n $的二分之三次方:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">block = <span class="built_in">pow</span>(n, (<span class="keyword">double</span>)<span class="number">2</span> / (<span class="keyword">double</span>)<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>然后复杂度大概就是 $O( n^ \frac {5}{3})$.</p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE:"></a>CODE:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum, c[maxm], a[maxn], ans[maxn], belong[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l]</span><br><span class="line">                   ? (belong[r] == belong[a.r] ? pre &lt; a.pre</span><br><span class="line">                                               : belong[r] &lt; belong[a.r])</span><br><span class="line">                   : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn], modi[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cntq, cntc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum += (++c[x] == <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum -= (--c[x] == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mocap[x].l &lt;= modi[t].l &amp;&amp; mocap[x].r &gt;= modi[t].l) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[modi[t].l]);</span><br><span class="line">        <span class="built_in">add</span>(modi[t].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[modi[t].l], modi[t].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">pow</span>(n, (<span class="keyword">double</span>)<span class="number">2</span> / (<span class="keyword">double</span>)<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            mocap[++cntq].l = <span class="built_in">read</span>();</span><br><span class="line">            mocap[cntq].r = <span class="built_in">read</span>();</span><br><span class="line">            mocap[cntq].pre = cntc;</span><br><span class="line">            mocap[cntq].id = cntq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            modi[++cntc].l = <span class="built_in">read</span>();  <span class="comment">//注意这里的l指的是修改位置pos</span></span><br><span class="line">            modi[cntc].r = <span class="built_in">read</span>();    <span class="comment">//注意这里的r是修改权值val</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + cntq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; mocap[i].l) l--, <span class="built_in">add</span>(a[l]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; mocap[i].l) <span class="built_in">del</span>(a[l]), l++;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; mocap[i].r) <span class="built_in">del</span>(a[r]), r--;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; mocap[i].r) r++, <span class="built_in">add</span>(a[r]);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; mocap[i].pre) t++, <span class="built_in">update</span>(i, t);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; mocap[i].pre) <span class="built_in">update</span>(i, t), t--;</span><br><span class="line">        ans[mocap[i].id] = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><p><a href="https://www.luogu.com.cn/problem/SP10707">SP10707 COT2 - Count on a tree II</a></p>
<p>这就是树上莫队板子题了。</p>
<p>顾名思义，树上莫队就是树上的莫队<del>这不nm废话吗</del></p>
<p>所以显然我们的策略就是要首先对树进行树剖，然后转化成线性结构，然后我们大力搞莫队就行了。</p>
<p>那么问题就来了，如何把他变成线性结构？</p>
<h3 id="前置知识-欧拉序"><a href="#前置知识-欧拉序" class="headerlink" title="前置知识 欧拉序"></a>前置知识 欧拉序</h3><p>众所周知，我们对树的遍历通常是两种序。<del>如果不知道那你现在知道了</del></p>
<p>分别是 $DFS$ 序和欧拉序。首先来区别一下这两种序。</p>
<h4 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h4><p>如图，我们的 $dfs$ 一般是这样的</p>
<p>![dfs]xuar7g8t.png)</p>
<p>这张图的dfs序为A-B-D-E-G-C-F-H</p>
<p>好 $DFS$ 就说完了。</p>
<p><del>什么？？这就说完了？</del></p>
<p><del>确实，毕竟咱这里主要不说这玩意</del></p>
<p>接下来进入正题，欧拉序！</p>
<h4 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h4><p>欧拉序<strong>就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序</strong></p>
<p>所以对于这棵树，他的欧拉序就是这样的：</p>
<p><img src="bt9j4wzf.png" alt="欧拉序"></p>
<p>欧拉序为A-B-D-D-E-G-G-E-B-C-F-H-H-F-C-A</p>
<p>其实欧拉序是有两种的，一种是记录入度个，另一个是入度和出度都记录。</p>
<p>树上莫队用的是第二种，也就是我们上面说到的这种。</p>
<h3 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h3><p>为什么要用到欧拉序呢？</p>
<p>首先回顾一下题意，要求我们找到一条路径上的颜色个数，也就是不同的数字个数。</p>
<p>从欧拉序的形式上看，我们其实可以借助欧拉序去找一找路径上究竟有哪些点，以及该如何记录。</p>
<p>这里我们设 $st[i]$ 表示访问到 $i$ 时加入欧拉序的时间，$ed[i]$ 表示回溯经过 $i$ 时加入欧拉序的时间</p>
<p>不妨设 $st[x]$&lt;$st[y]$（也就是先访问 $x$，再访问 $y$）</p>
<p>分情况讨论;</p>
<h4 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h4><p>如果 $LCA(x,y)=x$ ，这显然说明 $x$,$y$ 在同一条路径上。</p>
<p>于是我们取出 $st[x]$ 到 $st[y]$ 这一段区间，有的点会出现两次，有的点出现一次，应该明确出现两次的点对答案是没有贡献的，因为它进入了递归又在回溯时出去了，这证明这条路径一定是不经过这个子树的，于是我们只需要统计路径上出现两次的点。</p>
<p>我们拿上面的图来举例子：</p>
<p><img src="bt9j4wzf.png" alt="欧拉序"></p>
<p>如果两个点分别是 $A$,$G$ ,那么 $st[A]-st[G]$ 显然是 $A-B-D-D-E-G$</p>
<p>出现两次的点是 $D$。</p>
<p>于是我们发现我们的路径 $A-G$ 上恰好是没有点 $D$ 的，于是……</p>
<p>懂了吧</p>
<h4 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h4><p>如果 $LCA(x,y) \ne x$ ，这显然说明 $x$,$y$ 在两棵不同的子树内。</p>
<p>于是我们取出 $ed[x]-st[y]$</p>
<p><img src="bt9j4wzf.png" alt="欧拉序"></p>
<p>依然对于这张图，我们举例子：</p>
<p>如果两个点分别是 $D$,$C$</p>
<p>于是 $ed[D]-st[C]$ 显然就是：</p>
<p>$D-E-G-G-E-B-C$</p>
<p>同样的，我们只统计出现一次的点，两次的点也不统计。</p>
<p>但是有这样一个问题，我们上面的过程是有一个小问题的。</p>
<p>我们没有统计 $LCA$ ！</p>
<p>后果不太严重，加上就好了 <del>/cy</del></p>
<p>至于如何判断第一次与第二次的问题，这个很简单，我们多记录一个 $use[x]$，表示 $x$ 这个点有没有被加入，每次处理的时候如果 $use[x]=0$ 则需要添加节点；如果 $use[x]=1$ 则需要删除节点，每次处理之后都对 $use[x]$ 异或 $1$ 就可以了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    used[x] ? <span class="built_in">del</span>(x) : <span class="built_in">add</span>(x);</span><br><span class="line">    used[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下面是一些细节"><a href="#下面是一些细节" class="headerlink" title="下面是一些细节"></a>下面是一些细节</h4><ul>
<li>欧拉序直接用树剖就行了，在 $dfs1$ 中顺便就搞出来了。</li>
</ul>
<p>$LCA$ 顺便也就搞出来了，<del>多香</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    deep[u] = deep[f] + <span class="number">1</span>;</span><br><span class="line">    st[u] = ++tot;</span><br><span class="line">    pot[tot] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ed[u] = ++tot;</span><br><span class="line">    pot[tot] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (top[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[x] &lt; deep[y] ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一定要记得，欧拉序的长度是节点长度的 $2$ 倍，所以分块的时候要分 $n&lt;&lt;1$ </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">    belong[i] = i / block + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个题要离散化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Discretization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + n) - data - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + len, a[i]) - data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><del>其实我觉得还是挺恶心的</del></p>
<h3 id="CODE：-1"><a href="#CODE：-1" class="headerlink" title="CODE："></a>CODE：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block;</span><br><span class="line"><span class="keyword">int</span> a[maxn], data[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn], ed[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> belong[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, lca, ans;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l] ? r &lt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[maxn &lt;&lt; <span class="number">1</span>], to[maxn &lt;&lt; <span class="number">1</span>], head[maxn], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[++cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> deep[maxn], fa[maxn], top[maxn], son[maxn], size[maxn], pot[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    deep[u] = deep[f] + <span class="number">1</span>;</span><br><span class="line">    st[u] = ++tot;</span><br><span class="line">    pot[tot] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ed[u] = ++tot;</span><br><span class="line">    pot[tot] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = head[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (top[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Discretization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + n) - data - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(data + <span class="number">1</span>, data + <span class="number">1</span> + len, a[i]) - data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[x] &lt; deep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> used[maxn], c[maxn], sum, ans[maxn];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum += (++c[a[x]] == <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; sum -= (--c[a[x]] == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    used[x] ? <span class="built_in">del</span>(x) : <span class="built_in">add</span>(x);</span><br><span class="line">    used[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    block = n / <span class="built_in">sqrt</span>(m * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = data[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">        belong[i] = i / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Discretization</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[x] &gt; st[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">int</span> lca = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">        <span class="keyword">if</span> (lca == x)</span><br><span class="line">            mocap[i].l = st[x], mocap[i].r = st[y];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mocap[i].l = ed[x], mocap[i].r = st[y], mocap[i].lca = lca;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; mocap[i].l) <span class="built_in">calc</span>(pot[l]), l++;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; mocap[i].l) l--, <span class="built_in">calc</span>(pot[l]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; mocap[i].r) r++, <span class="built_in">calc</span>(pot[r]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; mocap[i].r) <span class="built_in">calc</span>(pot[r]), r--;</span><br><span class="line">        <span class="keyword">if</span> (mocap[i].lca) <span class="built_in">calc</span>(mocap[i].lca);</span><br><span class="line">        mocap[i].ans = sum;</span><br><span class="line">        <span class="keyword">if</span> (mocap[i].lca) <span class="built_in">calc</span>(mocap[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ans[mocap[i].id] = mocap[i].ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回滚莫队（不删除莫队（少删除莫队））"><a href="#回滚莫队（不删除莫队（少删除莫队））" class="headerlink" title="回滚莫队（不删除莫队（少删除莫队））"></a>回滚莫队（不删除莫队（少删除莫队））</h2><p><del>首先这个玄学的名字是从题解里看到的。</del></p>
<p><a href="https://www.luogu.com.cn/problem/P5906">P5906 【模板】回滚莫队&amp;不删除莫队</a></p>
<p>这个题让我们求的玩意就非常诡异。</p>
<p>给定一个序列，多次询问一段区间 $[l,r]$，求区间中相同的数的最远间隔距离。</p>
<p>序列中两个元素的间隔距离指的是两个元素下标差的绝对值。</p>
<p>对于普通的莫队操作，一般是需要支持增加和修改两种操作。</p>
<p>可是有这样的一类题目，在你进行完移动操作以后需要立即更新答案（例如本题）</p>
<p>于是可以发现一个问题：在删除左侧以后，我们需要知道次左，然后又需要知道次左的次左……</p>
<p>于是这玩意就直接凉了。</p>
<p>于是有这么个玩意名字叫回滚莫队，就可以解决这样的问题。</p>
<p>既然我们删除操作不好搞，那我们就不删除！（或者是少删除（这也是不删除莫队名字的由来））</p>
<p>就是说要用增加来代替删除操作。</p>
<p>右端点的增加很好说，我们在排序的时候已经保证右端点有序。</p>
<p>于是就是左端点的问题了。</p>
<p>我们可以把左指针强行拉到右端点，然后让左指针往左走。然后再拉回右端点，然后再往左走。</p>
<p>记录答案只需要先算一算右边的答案，然后再算一算左边的（ $add()$ ） </p>
<p>然后算完以后我们就把左端点拉回来，然后把左边的贡献删掉就行了。</p>
<h3 id="本题-1"><a href="#本题-1" class="headerlink" title="本题"></a>本题</h3><p>我们记左指针为 $l$，右指针为 $r$，当前块的右边界（分界线）为 $mid$， $[l,mid]$ 为左区间，$[mid,r]$ 为右区间</p>
<p>然后答案会有三种情况出现：</p>
<ul>
<li><p>答案完全在左区间中</p>
</li>
<li><p>答案完全在右区间中</p>
</li>
<li><p>答案一部分在左区间中，一部分在右区间中</p>
</li>
</ul>
<p>首先答案的右端点是单调的，因此取个 $\max$ 即可，与当前扫到的下标相减就解决了情况 $1$ 和 $3$,</p>
<p>对于情况 $2$，我们要额外记录一个值，记录一个数在右区间中第一次出现的位置</p>
<p>假如 $max$ 也在右区间中，相减，就得到了情况2的答案。</p>
<h4 id="细节相关"><a href="#细节相关" class="headerlink" title="细节相关"></a>细节相关</h4><p>$1$：如果左右边界都在同一个块内就暴力计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last[maxn], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) last[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!last[a[i]])</span><br><span class="line">            last[a[i]] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i - last[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$2$：本题需要离散化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Discretization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">unique</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n) - num - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + tmp, a[i]) - num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$3$ :由于回滚的原因，所以现在的左询问一定是小于上一次的左询问，现在的右询问一定大于上一次的右询问，所以原来莫队的四个 $while$ 只剩下了两个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; mocap[i].r) &#123;</span><br><span class="line">    r++;</span><br><span class="line">    mr[a[r]] = r;</span><br><span class="line">    <span class="keyword">if</span> (!ml[a[r]]) ml[a[r]] = r;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, r - ml[a[r]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &gt; mocap[i].l) &#123;</span><br><span class="line">    l--;</span><br><span class="line">    <span class="keyword">if</span> (mr[a[l]])</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, mr[a[l]] - l);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mr[a[l]] = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ans[mocap[i].id] = ans;</span><br></pre></td></tr></table></figure>

<p>$4$：最后不要忘记把左端点再拉回来：</p>
<p>同时有这样一个问题，再左端点走过去的时候，会影响贡献，又因为我们每次都要把左端点拉回最右侧，所以这个贡献对以后的询问是没什么用的，于是我们需要先记录一下当前的答案，再统计完左侧，记录完答案以后，把左端点拉回最右侧的时候去掉左侧的贡献，再把 $ans$ 更新回来就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= nowr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mr[a[l]] == l) mr[a[l]] = <span class="number">0</span>;</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = ans;  <span class="comment">//在l,r之间</span></span><br><span class="line"></span><br><span class="line">ans = tmp;  <span class="comment">//把左端点拉回来以后</span></span><br></pre></td></tr></table></figure>

<p>$5$：其实还有一个细节，就是 $memset$ 也许会影响常数大小，于是我们不必要每次清空整个数组，只需要记录每次更改了哪些就可以了。</p>
<p>最后再把这些清零就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> () &#123;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q[i].r) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        mr[a[r]] = r;</span><br><span class="line">        <span class="keyword">if</span> (!st[a[r]]) st[a[r]] = r, clear[++cn] = a[r];  <span class="comment">//就是这里</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - st[a[r]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cn; i++) ma[clear[i]] = st[clear[i]] = <span class="number">0</span>;  <span class="comment">//在大循环外</span></span><br></pre></td></tr></table></figure>

<p>不过我没用，其实 $memset$ 的常数并不算太大，常数瓶颈并不在这里。<del>确信</del></p>
<p>细节大概就这么多了。</p>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE:"></a>CODE:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block, tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], num[maxn], belong[maxn], Ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ml[maxn], mr[maxn];  <span class="comment">// ml是最早出现的位置，mr是最晚出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nowr, l, r;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l] ? r &lt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Discretization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">unique</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n) - num - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + tmp, a[i]) - num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last[maxn], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) last[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!last[a[i]])</span><br><span class="line">            last[a[i]] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i - last[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = num[i] = <span class="built_in">read</span>();</span><br><span class="line">        belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot = belong[n];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Discretization</span>();</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        mocap[i].l = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].r = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>, i = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowr = <span class="built_in">min</span>(n, j * block), l = nowr + <span class="number">1</span>, r = l - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(ml, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ml));</span><br><span class="line">        <span class="built_in">memset</span>(mr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; belong[mocap[i].l] == j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[mocap[i].r] == j) &#123;</span><br><span class="line">                Ans[mocap[i].id] = <span class="built_in">calc</span>(mocap[i].l, mocap[i].r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; mocap[i].r) &#123;</span><br><span class="line">                r++;</span><br><span class="line">                mr[a[r]] = r;</span><br><span class="line">                <span class="keyword">if</span> (!ml[a[r]]) ml[a[r]] = r;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r - ml[a[r]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tmp = ans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &gt; mocap[i].l) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                <span class="keyword">if</span> (mr[a[l]])</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, mr[a[l]] - l);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mr[a[l]] = l;  <span class="comment">//最后出现的位置可能在左区间中</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Ans[mocap[i].id] = ans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= nowr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mr[a[l]] == l) mr[a[l]] = <span class="number">0</span>;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-AT1219-歴史の研究"><a href="#例题-AT1219-歴史の研究" class="headerlink" title="例题 AT1219 歴史の研究"></a>例题 AT1219 歴史の研究</h3><p><a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></p>
<p>首先这个题比上一个好写一些</p>
<p>但是作为一个菜鸡还是调了很久。</p>
<p>总结了以下槽点：</p>
<p>$1$：这个题依然要离散化。</p>
<p>离散化完了以后千万别忘记你已经离散化了！！！</p>
<p>不要傻乎乎的再使用原来的数据了</p>
<p><del>这充分说明我是个傻逼，这么低级的错误也能犯</del></p>
<p>$2$：这个题要开 $long \ long$</p>
<p>开了 $int$ 然后 $WA$ 了，百思不得其解，然后发现要 $long \ long$</p>
<p>好了其实别的几乎没有了，都是我比较傻逼</p>
<p>代码放这了</p>
<h4 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE:"></a>CODE:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block, tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], num[maxn], ans[maxn], belong[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Discretization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">unique</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n) - num - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + tmp, a[i]) - num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l] ? r &lt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cntt[maxn];</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        cntt[a[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        cntt[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, cntt[a[i]] * num[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = num[i] = <span class="built_in">read</span>();</span><br><span class="line">        belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tot = belong[n];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Discretization</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        mocap[i].l = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].r = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>, i = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowr = <span class="built_in">min</span>(n, j * block), l = nowr + <span class="number">1</span>, r = l - <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">        <span class="keyword">for</span> (; belong[mocap[i].l] == j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[mocap[i].r] == j) &#123;</span><br><span class="line">                ans[mocap[i].id] = <span class="built_in">calc</span>(mocap[i].l, mocap[i].r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (r &lt; mocap[i].r) &#123;</span><br><span class="line">                r++;</span><br><span class="line">                c[a[r]]++;</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, c[a[r]] * num[a[r]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tmp = sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &gt; mocap[i].l) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                c[a[l]]++;</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, c[a[l]] * num[a[l]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[mocap[i].id] = sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= nowr) &#123;</span><br><span class="line">                c[a[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变式-Rmq-Problem-mex"><a href="#变式-Rmq-Problem-mex" class="headerlink" title="变式 Rmq Problem / mex"></a>变式 Rmq Problem / mex</h3><p><a href="https://www.luogu.com.cn/problem/P4137">P4137 Rmq Problem / mex</a></p>
<p>后来我在智能推荐里找到了这道题。</p>
<p>一眼看上去这个题面，貌似之前讲过的。</p>
<p>之前讲的是可持久化线段树的做法。</p>
<p>但是现在发现这玩意还可以用回滚莫队来搞。</p>
<p>不过做了这道题确实颠覆和加深了我对回滚莫队的认识。</p>
<p>题目很简洁：求给定区间内没有出现的最小的自然数是多少。</p>
<p>稍加思考可以发现，这个东西的加入操作是没有办法做到 $O(1)$ 的。</p>
<p>比如目前有一个序列：$0,6,3,5,4,2$ ，现在没有出现的最小自然数是 $1$。</p>
<p>如果随着查询端点的移动，下一个位置要加入的数字恰好是 $1$，那么现在这个区间就出现 $1$ 了，于是我们要统计最小没有出现过的自然数的话就要从新统计。</p>
<p>这是不好的。</p>
<p>反观删除操作，如果还是上面的例子，现在右端点收缩，$2$ 就会被删除，于是我们只需要比较一下 $2,1$ 的大小关系，就可以在 $O(1)$ 的时间内确定新的 $mex$ 。</p>
<p>这启示我们需要使用一个只资瓷删除而不资瓷增加的莫队。</p>
<p>而根据我们刚刚学回滚莫队所联想的只资瓷增加不资瓷删除的回滚莫队相类比，我们可以将每个块按照<strong>左端点递增排序，右端点递减排序</strong>。</p>
<p>首先求出整个序列的 $mex$ 。</p>
<p>然后我们让右端点从整个序列的右侧不断地向左删除，同时左端点向右删除，处理完了以后我们让左端点回滚到块的左端点。这样就可以实现了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l] ? r &gt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br></pre></td></tr></table></figure>

<p>可以画个图理解一下：</p>
<p><img src="rahnqr3l.png"></p>
<p>这个是普通的回滚莫队</p>
<p><img src="7ov6gaxr.png"></p>
<p>这个是只减不增的回滚莫队</p>
<p>处理完一个块的询问之后，左指针必然会回滚到块的左端点</p>
<p>这时，类似只加不减的回滚莫队，先暴力地把右指针遍历到整个序列的最右端，然后左指针向右删除到下一个块的左端点。</p>
<h4 id="细节相关："><a href="#细节相关：" class="headerlink" title="细节相关："></a>细节相关：</h4><h5 id="贡献与端点移动的先后关系："><a href="#贡献与端点移动的先后关系：" class="headerlink" title="贡献与端点移动的先后关系："></a>贡献与端点移动的先后关系：</h5><p>之前我们写的回滚莫队是只增不减的，现在的是只减不增的。</p>
<ul>
<li>在只增不减的回滚莫队中：</li>
</ul>
<p>我们已经处理过当前询问内的贡献，现在需要扩大范围，但是当前的贡献也要保留，所以应该先跳动端点指针，然后再增加贡献：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; mocap[i].r) &#123;</span><br><span class="line">    r++;</span><br><span class="line">    c[a[r]]++;</span><br><span class="line">    sum = <span class="built_in">max</span>(sum, c[a[r]] * num[a[r]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &gt; mocap[i].l) &#123;</span><br><span class="line">    l--;</span><br><span class="line">    c[a[l]]++;</span><br><span class="line">    sum = <span class="built_in">max</span>(sum, c[a[l]] * num[a[l]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（这两个片段是歴史の研究里面的）</p>
<ul>
<li>在只减不增的回滚莫队中：</li>
</ul>
<p>再来看这道题，只删除不增加：</p>
<p>我们需要缩小范围，也就是要逐个删除贡献，于是当前位置的贡献已经没有用了，所以要先删掉，才能移动指针去修改下一个位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &gt; mocap[i].r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[r] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[r]]) p = <span class="built_in">min</span>(p, a[r]);</span><br><span class="line">    r--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; mocap[i].l) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[l] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[l]]) tmp = <span class="built_in">min</span>(tmp, a[l]);</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于左右端点的位置记录与移动"><a href="#关于左右端点的位置记录与移动" class="headerlink" title="关于左右端点的位置记录与移动"></a>关于左右端点的位置记录与移动</h5><p>因为以往的回滚都是要回到当前块的右端点，所以我们每次只记录右端点就可以了，但是这道题是要回到左端点，所以需要记录左端点。</p>
<p>处理完一个块以后，我们要控制左端点移动到下一个快的左端点，所以这些问题都要注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nowr = <span class="built_in">min</span>(n, j*block), l = nowr + <span class="number">1</span>, r = l - <span class="number">1</span>, sum = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>（依然是歴史の研究里面的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nowl = <span class="built_in">min</span>(n, (j - <span class="number">1</span>) * block) + <span class="number">1</span>, l = nowl, r = n, p = mex,</span><br><span class="line">    nxtl = <span class="built_in">min</span>(n, j*block) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>（本题目）</p>
<p>而且要注意，我们的右端点是要从整个序列的右端开始走的，所以要 $r=n$ .</p>
<p>然后就是把右端点拉回最右侧，左端点拉到下一个块，这个东西也是平常的回滚莫队没有的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">    r++;</span><br><span class="line">    <span class="keyword">if</span> (a[r] &lt;= n + <span class="number">1</span>) cnt[a[r]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; nxtl) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[l] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[l]]) mex = <span class="built_in">min</span>(mex, a[l]);</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于在同一个块内的暴力计算"><a href="#关于在同一个块内的暴力计算" class="headerlink" title="关于在同一个块内的暴力计算"></a>关于在同一个块内的暴力计算</h5><p>首先这个东西有两种实现方法;</p>
<p>$1$：开一个全局数组，每次暴力算就先用一用，然后统计完再把贡献删掉：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (belong[mocap[i].r] == j) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> k = mocap[i].l; k &lt;= mocap[i].r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt;= n + <span class="number">1</span>) cntt[a[k]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cntt[res]) res++;</span><br><span class="line">    ans[mocap[i].id] = res;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> k = mocap[i].l; k &lt;= mocap[i].r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt;= n + <span class="number">1</span>) cntt[a[k]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我不喜欢。</p>
<p>如果你和我一样，都喜欢单独搞一个函数，然后在函数里直接统计，这样就可以不删除贡献了，用完就可以扔了。<del>可以不负责的感觉好爽</del></p>
<p>但是一定要记得初始化！！</p>
<p>不然你会 $WA$ 的很惨~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cntt[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(cntt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cntt));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n + <span class="number">1</span>) cntt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cntt[res]) res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他问题就没啥可说的了。</p>
<p>放下代码</p>
<h4 id="CODE：-2"><a href="#CODE：-2" class="headerlink" title="CODE："></a>CODE：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define LawrenceSivan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, belong[maxn], block, tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxn], mex, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MOCAP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MOCAP &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> belong[l] == belong[a.l] ? r &gt; a.r : belong[l] &lt; belong[a.l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mocap[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cntt[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(cntt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cntt));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n + <span class="number">1</span>) cntt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cntt[res]) res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LawrenceSivan</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;aa.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n + <span class="number">1</span>) cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt[mex]) mex++;</span><br><span class="line"></span><br><span class="line">    tot = belong[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        mocap[i].l = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].r = <span class="built_in">read</span>();</span><br><span class="line">        mocap[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(mocap + <span class="number">1</span>, mocap + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowl = <span class="built_in">min</span>(n, (j - <span class="number">1</span>) * block) + <span class="number">1</span>, l = nowl, r = n, p = mex,</span><br><span class="line">            nxtl = <span class="built_in">min</span>(n, j * block) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; belong[mocap[i].l] == j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[mocap[i].r] == j) &#123;</span><br><span class="line">                ans[mocap[i].id] = <span class="built_in">calc</span>(mocap[i].l, mocap[i].r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (r &gt; mocap[i].r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[r] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[r]]) p = <span class="built_in">min</span>(p, a[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tmp = p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &lt; mocap[i].l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[l] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[l]]) tmp = <span class="built_in">min</span>(tmp, a[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[mocap[i].id] = tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &gt; nowl) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                <span class="keyword">if</span> (a[l] &lt;= n + <span class="number">1</span>) cnt[a[l]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (a[r] &lt;= n + <span class="number">1</span>) cnt[a[r]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; nxtl) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &lt;= n + <span class="number">1</span> &amp;&amp; !--cnt[a[l]]) mex = <span class="built_in">min</span>(mex, a[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
        <tag>暴力</tag>
        <tag>离线</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式</title>
    <url>/63849/</url>
    <content><![CDATA[<p>唔~</p>
<span id="more"></span>

<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p>多项式是有变量和系数通过有限次加减法、乘法和自然数幂次的乘方运算得到的代数表达式，是整式的一种。</p>
<h2 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h2><h3 id="系数表示法"><a href="#系数表示法" class="headerlink" title="系数表示法"></a>系数表示法</h3><p>给定一个<a href="https://zh.wikipedia.org/wiki/%E7%8E%AF_(%E4%BB%A3%E6%95%B0)">环</a> $R$（$R$ 通常是<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8D%A2%E7%8E%AF">交换环</a>，可以是有理数、实数或者复数等等）以及一个未知数 $x$，则任何形同：</p>
<p>$$a_0 + a_1x + \cdots + a_{n - 1}x^{n - 1} + a_nx^n$$</p>
<p>的代数表达式叫做 $R$ 上的一元多项式。其中 $a_o, a_1, \cdots, a_n$ 是 $R$ 中的元素。</p>
<p>在不至于混淆的情形下，一般将一元多项式简称为多项式，下面说的都是一元多项式。</p>
<p>由于多项式的和、差、积都是多项式，即形成一个闭环 $R[x]$，称作 $R$ 上的<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF">多项式环</a>。</p>
<h4 id="次数"><a href="#次数" class="headerlink" title="次数"></a>次数</h4><p>对于多项式 $A = a_0 + a_1x + \cdots + a_{n - 1}x^{n - 1} + a_nx^n$，若 $a_n \neq 0$ 则多项式 $A$ 的次数（度）为 $n$，记作 $\deg A = n$。</p>
<p>若 $a_n = 1$，则称 $A$ 为首一多项，同时规定 $\deg 0 = -\infty$。</p>
<p>多项式的次数有一下几个性质：</p>
<ul>
<li><p>$\deg(A + B) \le \max(\deg A, \deg B)$</p>
</li>
<li><p>$\deg(A \cdot B) = \deg A + \deg B$</p>
</li>
</ul>
<h4 id="系数"><a href="#系数" class="headerlink" title="系数"></a>系数</h4><p>定义 $[x^n ]A$ 表示取出 $A$ 的 $x^n$ 的系数。（不是标准记号）</p>
<h3 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h3><p>点值表示法是把这个多项式看成一个函数，从上面选取 $n + 1$ 个点，从而利用这 $n + 1$ 个点来唯一地表示这个 $n$ 次函数。</p>
<h2 id="多项式的运算"><a href="#多项式的运算" class="headerlink" title="多项式的运算"></a>多项式的运算</h2><h3 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h3><p>同次项系数直接相加即可。</p>
<p>$A = a_0 + a_1x + \cdots +a_nx^n$</p>
<p>$B = b_0 + b_1x + \cdots + b_nx^n$</p>
<p>$A + B = (a_0 + b_0) + (a_1 + b_1)x + \cdots + (a_n + b_n)x^n$</p>
<h3 id="多项式减法"><a href="#多项式减法" class="headerlink" title="多项式减法"></a>多项式减法</h3><p>同加法。</p>
<h3 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h3><p>$A = a_0 + a_1x + \cdots +a_nx^n$</p>
<p>$B = b_0 + b_1x + \cdots + b_nx^n$</p>
<p>$[x^k](A \cdot B) = \sum_{i = 0}^k[x^i]A \cdot [x^{k - i}]B, k = 0, 1, \cdots, \deg A + \deg B$</p>
<p>一个 $\Omicron(n^2)$ 的做法是直接每项相乘（直接算上面的式子），但是这样太慢了，快速傅里叶变换（FFT）可以在 $\Omicron(n \log n)$ 的时间内做到。</p>
<h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>对于多项式 $A$、$B$，存在唯一的 $Q$、$R$ 使得：</p>
<p>$$A = QB + R, \deg R &lt; \deg B$$</p>
<p>我们称 $Q$ 为商，$R$ 为余数，也记作：<br>$$A \equiv R \pmod B$$</p>
<p>当 $\deg A \ge \deg B$ 时有 $\deg Q = \deg A - \deg B$，否则有 $Q = 0$。</p>
<h3 id="多项式逆元"><a href="#多项式逆元" class="headerlink" title="多项式逆元"></a>多项式逆元</h3><p>对于多项式 $A$，若存在 $B$ 满足：</p>
<p>$$A \cdot B \equiv 1 \pmod{x^n}$$</p>
<p>则称 $B$ 为 $A$ 在模 $x^n$ 意义下的逆元，记作 $A^{-1}$，当 $\deg B &lt; n$ 时逆元唯一。</p>
<h2 id="系数表示与点值表示的转换"><a href="#系数表示与点值表示的转换" class="headerlink" title="系数表示与点值表示的转换"></a>系数表示与点值表示的转换</h2><h3 id="系数表示-to-点值表示（多点求值）"><a href="#系数表示-to-点值表示（多点求值）" class="headerlink" title="系数表示 $\to$ 点值表示（多点求值）"></a>系数表示 $\to$ 点值表示（多点求值）</h3><p>若 $x_i$ 任取可使用直接插值、秦九韶算法、快速插值。</p>
<h3 id="点值表示-to-系数表示（插值）"><a href="#点值表示-to-系数表示（插值）" class="headerlink" title="点值表示 $\to$ 系数表示（插值）"></a>点值表示 $\to$ 系数表示（插值）</h3><p>有 $\Omicron(n^3)$ 的高斯消元和 $\Omicron(n^2)$ 的拉格朗日插值。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高等代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树, Segment Tree</title>
    <url>/43706/</url>
    <content><![CDATA[<p>这东西当初恶心了我很久了。</p>
<span id="more"></span>

<h1 id="color-Green-code-oi"><a href="#color-Green-code-oi" class="headerlink" title="$\color{Green}code - oi$"></a>$\color{Green}code - oi$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;<span class="keyword">return</span> f &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;<span class="keyword">return</span> f &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ll v;</span><br><span class="line">    ll add;</span><br><span class="line">    <span class="built_in">node</span>() : <span class="built_in">add</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125; st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;st[p].v = st[<span class="built_in">ls</span>(p)].v + st[<span class="built_in">rs</span>(p)].v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        st[p].v = a[l];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, m);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(l ,r);</span><br><span class="line">    st[<span class="built_in">ls</span>(p)].v += st[p].add * (m - l + <span class="number">1</span>);</span><br><span class="line">    st[<span class="built_in">rs</span>(p)].v += st[p].add * (r - m);</span><br><span class="line">    st[<span class="built_in">ls</span>(p)].add += st[p].add;</span><br><span class="line">    st[<span class="built_in">rs</span>(p)].add += st[p].add;</span><br><span class="line">    st[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; cl || cr &lt; nl) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cl &lt;= nl &amp;&amp; nr &lt;= cr) &#123;</span><br><span class="line">        st[p].v += k * (nr - nl + <span class="number">1</span>);</span><br><span class="line">        st[p].add += k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p, nl, nr);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(nl, nr);</span><br><span class="line">    <span class="built_in">plus</span>(<span class="built_in">ls</span>(p), nl, m, cl, cr, k);</span><br><span class="line">    <span class="built_in">plus</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, nr, cl, cr, k);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; ql || qr &lt; nl) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= nl &amp;&amp; nr &lt;= qr) <span class="keyword">return</span> st[p].v;</span><br><span class="line">    <span class="built_in">push_down</span>(p, nl, nr);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(nl, nr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(p), nl, m, ql, qr) + <span class="built_in">query</span>(<span class="built_in">rs</span>(p), m + <span class="number">1</span>, nr, ql, qr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="color-Green-code-poject"><a href="#color-Green-code-poject" class="headerlink" title="$\color{Green}code - poject$"></a>$\color{Green}code - poject$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segment_tree</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _ls(<span class="keyword">int</span> f) &#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _rs(<span class="keyword">int</span> f) &#123; <span class="keyword">return</span> f &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> _mid(<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line">    T *_a;</span><br><span class="line">    T _n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        T v;</span><br><span class="line">        T add;</span><br><span class="line">        <span class="built_in">node</span>() : <span class="built_in">add</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    &#125; * _st;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; _st[p].v = _st[_ls(p)].v + _st[_rs(p)].v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            _st[p].v = _a[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = _mid(l, r);</span><br><span class="line">            <span class="built_in">build</span>(_ls(p), l, m);</span><br><span class="line">            <span class="built_in">build</span>(_rs(p), m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">push_up</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = _mid(l, r);</span><br><span class="line">        _st[_ls(p)].v += _st[p].add * (m - l + <span class="number">1</span>);</span><br><span class="line">        _st[_rs(p)].v += _st[p].add * (r - m);</span><br><span class="line">        _st[_ls(p)].add += _st[p].add;</span><br><span class="line">        _st[_rs(p)].add += _st[p].add;</span><br><span class="line">        _st[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _plus(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, T k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; cl || cr &lt; nl) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= nl &amp;&amp; nr &lt;= cr) &#123;</span><br><span class="line">            _st[p].v += k * (nr - nl + <span class="number">1</span>);</span><br><span class="line">            _st[p].add += k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, nl, nr);</span><br><span class="line">        <span class="keyword">int</span> m = _mid(nl, nr);</span><br><span class="line">        _plus(_ls(p), nl, m, cl, cr, k);</span><br><span class="line">        _plus(_rs(p), m + <span class="number">1</span>, nr, cl, cr, k);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    T _query(<span class="keyword">int</span> p, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; ql || qr &lt; nl) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= nl &amp;&amp; nr &lt;= qr) <span class="keyword">return</span> _st[p].v;</span><br><span class="line">        <span class="built_in">push_down</span>(p, nl, nr);</span><br><span class="line">        <span class="keyword">int</span> m = _mid(nl, nr);</span><br><span class="line">        <span class="keyword">return</span> _query(_ls(p), nl, m, ql, qr) +</span><br><span class="line">               _query(_rs(p), m + <span class="number">1</span>, nr, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">segment_tree</span>(T n, T *a) : _n(n), _a(a) &#123;</span><br><span class="line">        _st = <span class="keyword">new</span> node[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, _n);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">segment_tree</span>() &#123; <span class="keyword">delete</span>[] _st; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T k)</span> </span>&#123; _plus(<span class="number">1</span>, <span class="number">1</span>, _n, l, r, k); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> _query(<span class="number">1</span>, <span class="number">1</span>, _n, l, r); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>区间最值, RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树, Scapegoat Tree</title>
    <url>/31534/</url>
    <content><![CDATA[<p>暴力拍扁。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>替罪羊树是基于暴力重构的数据结构，当判断出以2某个节点为根的子树失衡时就暴力压扁重构。</p>
<h2 id="判断是否重构"><a href="#判断是否重构" class="headerlink" title="判断是否重构"></a>判断是否重构</h2><p>每个节点都记两个标记： $\rm size$ 和 $\rm cnt$ ， $\rm size$ 为子树大小，包括已删除节点， $\rm cnt$ 是不包括已删除节点的子树大小，另定义一个常数 $\alpha$ ，对于某个节点当 $\rm p.son.size &gt; p.size \times \alpha$ 就失衡，我们就暴力拍扁重构， $\alpha$ 的取值为 $0.5 &lt; \alpha &lt; 1$ ，一般取 $0.7$ 或 $0.75$ 。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>我们每次只重构最高的失衡点，这样常数小。重构时只要将中序遍历存到数组或 <code>std::vector</code> 里就行，然后二分重构。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>均摊 $\Theta(\log n)$ 。</p>
<h1 id="rm-color-green-code"><a href="#rm-color-green-code" class="headerlink" title="$\rm \color{green}code$"></a>$\rm \color{green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> (l + r) &gt;&gt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> n, op, x;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    node *l;</span><br><span class="line">    node *r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">bool</span> tag;  <span class="comment">// if deleted</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> l-&gt;cnt &gt; alpha * cnt || r-&gt;cnt &gt; alpha * cnt; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = !tag + l-&gt;size + r-&gt;size;</span><br><span class="line">        cnt = l-&gt;cnt + r-&gt;cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; * null, *root, **badtag;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;node *&gt; nv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(node *p,</span></span></span><br><span class="line"><span class="params"><span class="function">         nv &amp;v)</span> </span>&#123;  <span class="comment">// inorder traversal the sub tree to get the ordered sequence</span></span><br><span class="line">    <span class="keyword">if</span> (p == null) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(p-&gt;l, v);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;tag) v.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="built_in">dfs</span>(p-&gt;r, v);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tag) <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">build</span><span class="params">(nv &amp;v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">mid</span>(l, r);</span><br><span class="line">    node *p = v[m];</span><br><span class="line">    p-&gt;l = <span class="built_in">build</span>(v, l, m);</span><br><span class="line">    p-&gt;r = <span class="built_in">build</span>(v, m + <span class="number">1</span>, r);</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(node *&amp;p)</span> </span>&#123;</span><br><span class="line">    nv v;</span><br><span class="line">    <span class="built_in">dfs</span>(p, v);</span><br><span class="line">    p = <span class="built_in">build</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rinsert</span><span class="params">(node *&amp;p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == null) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;l = p-&gt;r = null;</span><br><span class="line">        p-&gt;tag = <span class="literal">false</span>;</span><br><span class="line">        p-&gt;size = p-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">        p-&gt;val = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;size++;</span><br><span class="line">        p-&gt;cnt++;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= p-&gt;val)</span><br><span class="line">            <span class="built_in">rinsert</span>(p-&gt;r, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">rinsert</span>(p-&gt;l, x);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;<span class="built_in">check</span>())</span><br><span class="line">            badtag = &amp;p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (badtag != &amp;null)</span><br><span class="line">            p-&gt;cnt -= (*badtag)-&gt;cnt - (*badtag)-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    badtag = &amp;null;</span><br><span class="line">    <span class="built_in">rinsert</span>(p, x);</span><br><span class="line">    <span class="keyword">if</span> (badtag != &amp;null) <span class="built_in">rebuild</span>(*badtag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findrank</span><span class="params">(node *p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt;= x)</span><br><span class="line">            p = p-&gt;l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += p-&gt;l-&gt;size + !p-&gt;tag;</span><br><span class="line">            p = p-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findval</span><span class="params">(node *p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;tag &amp;&amp; p-&gt;l-&gt;size + <span class="number">1</span> == x) <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;l-&gt;size &gt;= x)</span><br><span class="line">            p = p-&gt;l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x -= p-&gt;l-&gt;size + !p-&gt;tag;</span><br><span class="line">            p = p-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(node *p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;tag &amp;&amp; k == p-&gt;l-&gt;size + <span class="number">1</span>) &#123;</span><br><span class="line">        p-&gt;tag = <span class="literal">true</span>;</span><br><span class="line">        p-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;size--;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= p-&gt;l-&gt;size + !p-&gt;tag)</span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;l, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;r, k - p-&gt;l-&gt;size - !p-&gt;tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (flag) n = -n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    null = <span class="keyword">new</span> node;</span><br><span class="line">    root = null;</span><br><span class="line">    n = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        op = <span class="built_in">qread</span>(), x = <span class="built_in">qread</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">insert</span>(root, x);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">remove</span>(root, <span class="built_in">findrank</span>(root, x));</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findrank</span>(root, x));</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findval</span>(root, x));</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findval</span>(root, <span class="built_in">findrank</span>(root, x) - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">findval</span>(root, <span class="built_in">findrank</span>(root, x + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>替罪羊树</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理二进制对数表</title>
    <url>/52240/</url>
    <content><![CDATA[<p>预处理 $lb$ 表。</p>
<span id="more"></span>

<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mklb</span><span class="params">(T n, T *lb_table)</span> </span>&#123;</span><br><span class="line">    lb_table[<span class="number">1</span>] = <span class="number">0</span>, lb_table[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i = <span class="number">3</span>; i &lt;= n; ++i) lb_table[i] = lb_table[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>卡常</tag>
        <tag>预处理</tag>
        <tag>对数</tag>
        <tag>二进制对数</tag>
        <tag>对数表</tag>
      </tags>
  </entry>
  <entry>
    <title>【模板】 中国剩余定理, crt / 曹冲养猪</title>
    <url>/35448/</url>
    <content><![CDATA[<p>中国剩余定理的板子。</p>
<span id="more"></span>

<p>提交地址：<a href="https://www.luogu.com.cn/problem/P1495">洛谷 Luogu1495</a>，<a href="https://vijos.org/p/1164">Vijos VJ1164</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求解一元线性同余方程组。</p>
<p>设母猪有 $x$ 头。</p>
<p>求解</p>
<p>$$\begin{cases} x &amp;\equiv b_1 \pmod {a_1} \\ x &amp;\equiv b_2 \pmod {a_2} \\ &amp;\vdots \\ x &amp;\equiv b_k \pmod {a_k} \\ \end{cases} $$</p>
<p>假定 $a_i, a_j$ 互质。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>显然中国剩余定理求解即可。</p>
<h2 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可以用来求解一元线性同余方程组</p>
<p>$$\begin{cases} x &amp;\equiv a_1 \pmod {m_1} \\ x &amp;\equiv a_2 \pmod {m_2} \\ &amp;\vdots \\ x &amp;\equiv a_k \pmod {m_k} \\ \end{cases} $$</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>设所有模数的积为</p>
<p>$$M = \prod m_i$$</p>
<p>除了第 $i$ 个方程外模数的积为</p>
<p>$$M_i = \frac{M}{m_i}$$</p>
<p>， $M_i$ 在 $\mod{m_i}$ 下的逆元为 $M_i^{-1}$ ，</p>
<p>设</p>
<p>$$c_i = M_iM_i^{-1}$$</p>
<p>。</p>
<p>则有一解</p>
<p>$$x = \sum a_ic_i \pmod{M}$$</p>
<p>。</p>
<p>注意， $M_iM_i^{-1} \ne 1$ ，因为 $M_i^{-1}$ 是在 $\bmod {m_i}$ 的剩余系下的，所以在实数系下不一定成立。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>有了做法我们还应保证其正确<del>交给数学家</del>。</p>
<p>我们看到有 $ i = j$ 和 $i\ne j$ 两种情况，</p>
<p>当 $i = j$ 时</p>
<p>$$a_jM_iM_i^{-1} \equiv 0 \pmod m_i$$</p>
<p>当 $i \ne j$ 时</p>
<p>$$a_iM_iM_i^{-1} \equiv a_i \pmod{m_i}$$</p>
<p>所以有</p>
<p>$$\begin{aligned} a&amp;\equiv \sum_{j=1}^k a_jM_iM_i^{-1} &amp;\pmod {m_i} \\ &amp;\equiv a_iM_iM_i^{-1} &amp;\pmod {m_i} \\ &amp;\equiv a_iM_i(M^{-1}_i \bmod M_i) &amp;\pmod {m_i} \\ &amp;\equiv a_i &amp;\pmod {m_i} \end{aligned}$$</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by XYY1411</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fastio</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = ll&gt;</span><br><span class="line"><span class="keyword">inline</span> T <span class="built_in">iread</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    T n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//extgcd for inverse </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = ll&gt;</span><br><span class="line"><span class="keyword">inline</span> T <span class="built_in">extgcd</span>(T a, T b, T &amp;x, T &amp;y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    T d = extgcd&lt;T&gt;(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, a[<span class="number">20</span>], m[<span class="number">20</span>], Mi[<span class="number">20</span>], M = <span class="number">1</span>, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">iread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        M *= (m[i] = <span class="built_in">iread</span>());</span><br><span class="line">        a[i] = <span class="built_in">iread</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Mi[i] = M / m[i];</span><br><span class="line">        ll x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">extgcd</span>(Mi[i], m[i], x, y);</span><br><span class="line">        ::x += a[i] * Mi[i] * (x &lt; <span class="number">0</span> ? x + m[i] : x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, x % M);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>中国剩余定理, crt</tag>
      </tags>
  </entry>
  <entry>
    <title>上帝与集合的正确用法</title>
    <url>/55212/</url>
    <content><![CDATA[<p>扩展欧拉定理。</p>
<span id="more"></span>

<p>提交地址：<a href="https://www.luogu.com.cn/problem/P4139">洛谷 Luogu4139</a>，大视野在线测评 BZOJ3884</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求 $2^{2^{2^\cdots}} \mod p$ 。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>有扩展欧拉定理：</p>
<p>$$a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},\,&amp;\gcd(a,\,p)=1\\ a^b,&amp;\gcd(a,\,p)\ne1,\,b&lt;\varphi(p)\\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;\gcd(a,\,p)\ne1,\,b\ge\varphi(p) \end{cases} \pmod p$$</p>
<p>。</p>
<p>我们发现可以求 $2^{2^{2^\cdots}} \mod p$ 了。</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数（Euler’s totient function），即 $\varphi(n)$ ，表示的是小于等于 $n$ 的数中和 $n$ 互质的数的个数。</p>
<p>易得 $\varphi(1) = 1$ ，当 $n$ 为质数时，只有 $n$ 不与 $n$ 互质，所以此时 $\varphi(n) = n - 1$ 。</p>
<p>欧拉函数是积性函数，当 $a, b$ 互质时， $\varphi(a) \times \varphi(b) = \varphi(a \times b)$ ，因为与 $a$ 不互质的有 $a$ ，与 $b$ 不互质的有 $b$ ，与 $a \times b$ 不互质的有 $a, 2a, 3a, \cdots,ab, \cdots, 3b, 2b, b$ ，所以等式成立。</p>
<p>当 $n$ 是奇数时 $\varphi(2n) = \varphi(n)$ ，可由上式推出。</p>
<p>$n = \sum_{d \mid n} \varphi(d)$ ，用莫比乌斯反演证。</p>
<p>若 $p$ 为质数， 则 $\varphi(p^k) = p^k - p^{k - 1} = p^{k - 1}\times(p - 1)$ ，因为与 $p^k$ 不互质的数只有 $p$ 的倍数，一共 $p^{k - 1}$<br> 个，所以上式成立。</p>
<h3 id="求单独的欧拉函数"><a href="#求单独的欧拉函数" class="headerlink" title="求单独的欧拉函数"></a>求单独的欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛欧拉函数"><a href="#筛欧拉函数" class="headerlink" title="筛欧拉函数"></a>筛欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* phi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) phi[i] = <span class="number">0</span>;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!phi[i])</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">        phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若 $a, m$ 互质，则有 $a^{\varphi(m)} \equiv \pmod m$ 。</p>
<h3 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h3><p>剩余类也叫同余类，指全体整数按照对一个正整数的同余关系而分成的类。</p>
<h3 id="完全剩余系"><a href="#完全剩余系" class="headerlink" title="完全剩余系"></a>完全剩余系</h3><p>从模 $n$ 的每个剩余类中各取一个数，得到一个由 $n$ 个数组成的集合，叫做模 $n$ 的一个完全剩余系。</p>
<h3 id="简化剩余系"><a href="#简化剩余系" class="headerlink" title="简化剩余系"></a>简化剩余系</h3><p>简化剩余系(reduced residue system)也称既约剩余系或缩系，是 $m$ 的完全剩余系中与 $m$ 互素的数构成的子集，如果模 $m$ 的一个剩余类里所有数都与 $m$ 互素，就把它叫做与模 $m$ 互素的剩余类。在与模 $m$ 互素的全体剩余类中，从每一个类中各任取一个数作为代表组成的集合，叫做模 $m$ 的一个简化剩余系。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>通过简化剩余系构造一个与 $m$ 互质的数列。</p>
<p>设 $r_1, r_2, \cdots, r_{\varphi(m)}$ 为模 $m$ 意义下的一个简化剩余系，则 $ar_1, ar_2, \cdots, ar_{\varphi(m)}$ 也为模 $m$ 意义下的一个简化剩余系。所以 $r_1r_2 \cdots r_{\varphi(m)} \equiv ar_1 \cdot ar_2 \cdots ar_{\varphi(m)} \equiv a^{\varphi(m)}r_1r_2 \cdots r_{\varphi(m)} \pmod{m}$ ，可约去 $r_1r_2 \cdots r_{\varphi(m)}$ ，得证。</p>
<h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a><a href="https://oi-wiki.org/math/fermat/#_5">扩展欧拉定理</a></h2><p>$$a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},\,&amp;\gcd(a,\,p)=1\\ a^b,&amp;\gcd(a,\,p)\ne1,\,b&lt;\varphi(p)\\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;\gcd(a,\,p)\ne1,\,b\ge\varphi(p) \end{cases} \pmod p$$</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>有了扩展欧拉定理我们就可以递推求解了。</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm\color{Green}code$"></a>$\rm\color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, p, phi[maxp + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxp; i++)</span><br><span class="line">        <span class="keyword">if</span> (!phi[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= maxp; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j; </span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qmul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ret = ((ret % mod) + (a % mod)) % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = ((a % mod) + (a % mod)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ret = <span class="built_in">qmul</span>(ret, a, mod) % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = <span class="built_in">qmul</span>(a, a, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mod == <span class="number">1</span> ? <span class="number">0</span> :<span class="built_in">qpow</span>(<span class="number">2</span>, <span class="built_in">work</span>(phi[mod]) + phi[mod], mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_phi</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">work</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>扩展欧拉定理（数论）</tag>
      </tags>
  </entry>
  <entry>
    <title>Contest Start</title>
    <url>/8687/</url>
    <content><![CDATA[<p>这道题只有 6000 人做出来了，而 B 题有 8000 人，但其实还是很简单的。</p>
<span id="more"></span>

<h1 id="Contest-Start"><a href="#Contest-Start" class="headerlink" title="Contest Start"></a>Contest Start</h1><p>提交地址：<a href="https://www.luogu.com.cn/problem/CF1539A">洛谷 CF1539A</a>，<a href="https://codeforces.com/problemset/problem/1539/A">CodeForces CF1539A</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n$ 个人比赛，每隔 $x$ 分钟有一人开始比赛，每个人比赛时长为 $t$，当每个人比赛结束时会有一个不满意程度，为已经开始比赛（或现在开始比赛）但尚未完成比赛的参与者人数，求所有人的不满意程度。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>盯着看一会儿，发现前几个人的不满意程度不一样，后面的人则是比前面的人少一。</p>
<p>我们看这组数据 <code>4 2 5</code>：</p>
<p>第一、二个人的贡献为 $2$，第三个人为 $1$，第四个人没有贡献，和为 $5$。</p>
<p>这组 <code>10 2 10</code>：</p>
<p>我们发现前几个的贡献为 $5$ ，第五到第十贡献为 $5, 4, 3, 2, 1, 0$，和为 $35$。</p>
<p>我们发现了规律，前几个都是 $\lfloor t \div x \rfloor$，最后一个往前为 $0$ 到 $\lfloor t \div x \rfloor$ 的每次增加一的数列，那么答案就有了。</p>
<p>注意开 <code>long long</code>，如果 $\lfloor t \div x \rfloor &gt; n$ 的话等差数列是到不了 $\lfloor t \div x \rfloor$ 的，特判就行。</p>
<h2 id="color-green-text-code"><a href="#color-green-text-code" class="headerlink" title="$\color{green}\text{code}$"></a>$\color{green}\text{code}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll k, n, x, t, tmp, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x &gt;&gt; t;</span><br><span class="line">        tmp = t / x, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; tmp) &#123;</span><br><span class="line">            ans = (<span class="number">1</span> + n - <span class="number">1</span>) * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="number">1</span> + tmp) * tmp / <span class="number">2</span>;</span><br><span class="line">        n -= (<span class="number">1</span> + tmp);</span><br><span class="line">        cout &lt;&lt; ans + n * tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Odd Set</title>
    <url>/36375/</url>
    <content><![CDATA[<p>不得不说，这题很水。</p>
<span id="more"></span>

<h1 id="Odd-Set"><a href="#Odd-Set" class="headerlink" title="Odd Set"></a>Odd Set</h1><p>提交地址：<a href="https://www.luogu.com.cn/problem/CF1542A">洛谷 CF1542A</a>，<a href="http://codeforces.com/problemset/problem/1542/A">CodeForces CF1542A</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个有 $2n$ 个元素的元素可重复集合（类似于 C++ 中的 <code>std::multiset</code>），让你将其分成一个 $n$ 个每个有两个元素的对子，要求每个对子中的两个元素和为奇数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果两个数的和为奇数的话，那么只能是一奇一偶。</p>
<p>那么只要一半奇数一半偶数即可。</p>
<p>那么统计奇数和偶数个数即可，当个数相同时输出 <code>Yes</code>，反之输出 <code>No</code>。</p>
<h2 id="rm-color-green-code"><a href="#rm-color-green-code" class="headerlink" title="$\rm\color{green}code$"></a>$\rm\color{green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T <span class="built_in">qread</span>() &#123;</span><br><span class="line">    T n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> flag ? -n : n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t, n, k, cnt1, cnt2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        n = <span class="built_in">qread</span>() &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>; <span class="comment">// 多测清空</span></span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            k = <span class="built_in">qread</span>();</span><br><span class="line">            <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">                cnt1++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(cnt1 == cnt2 ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Plus and Multiply</title>
    <url>/25709/</url>
    <content><![CDATA[<p>做了半天才发现其实很简单……</p>
<span id="more"></span>

<h1 id="Plus-and-Multiply"><a href="#Plus-and-Multiply" class="headerlink" title="Plus and Multiply"></a>Plus and Multiply</h1><p>提交地址：<a href="https://www.luogu.com.cn/problem/CF1542B">洛谷 CF1542B</a>，<a href="http://codeforces.com/problemset/problem/1542/B">CodeForces CF1542B</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个集合：</p>
<ul>
<li>$1$ 在集合中。</li>
<li>如果 $x$ 在集合中，那么 $x \cdot a$ 和  $x + b$ 在集合中。</li>
</ul>
<p>给定 $a, b, n$ 判断 $n$ 是否在集合中。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们发现，有 $(a^{x_1} + y_1 \cdot b) \cdot a^{x_2} + y_2 \cdot b = a^{x_1 + x_2} + b \cdot (y_1 \cdot a^{x_2} + y_2)$，由于 $x$ 和 $y$ 是我们任意取的，那么 $y_1 \cdot a^{x_2} + y_2$ 可以用一个 $y$ 来表示，则上式化简为 $a^x + b \cdot y = n$。</p>
<p>将上式转化为 $n - a^x \equiv 0 \pmod b$， 这样我们直接枚举指数 $x$ 即可，复杂度为 $\Omicron(\log_an)$。</p>
<h2 id="rm-color-green-code"><a href="#rm-color-green-code" class="headerlink" title="$\rm\color{green}code$"></a>$\rm\color{green}code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T <span class="built_in">qread</span>() &#123;</span><br><span class="line">    T n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;-&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> flag ? -n : n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll a, b, n;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t = <span class="built_in">qread</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        n = qread&lt;ll&gt;(), a = qread&lt;ll&gt;(), b = qread&lt;ll&gt;();</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123; <span class="comment">// 注意这里要特判，如果 a 为一不特判会死循环</span></span><br><span class="line">            <span class="built_in">puts</span>((n - <span class="number">1</span>) % b == <span class="number">0</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i *= a)</span><br><span class="line">            <span class="keyword">if</span> ((n - i) % b == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">puts</span>(flag ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏表, Sparse Table, ST表</title>
    <url>/59112/</url>
    <content><![CDATA[<p>奇奇怪怪，写不出来。</p>
<span id="more"></span>

<h1 id="color-Green-code-oi"><a href="#color-Green-code-oi" class="headerlink" title="$\color{Green}code - oi$"></a>$\color{Green}code - oi$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> logn = <span class="number">21</span>, maxn = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][logn + <span class="number">1</span>], lg[maxn + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T <span class="built_in">iread</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    T n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makelog</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    lg[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r, s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">iread</span>(), m = <span class="built_in">iread</span>();</span><br><span class="line">    <span class="built_in">makelog</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; ++i) f[i][<span class="number">0</span>] = <span class="built_in">iread</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= logn; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        l = <span class="built_in">iread</span>(), r = <span class="built_in">iread</span>();</span><br><span class="line">        s = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[l][s], f[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="color-Green-code-poject"><a href="#color-Green-code-poject" class="headerlink" title="$\color{Green}code - poject$"></a>$\color{Green}code - poject$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  lb() 为二进制对数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sparse_table</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    T **_table;</span><br><span class="line">    T _n;</span><br><span class="line">    T _logn;</span><br><span class="line">    <span class="keyword">inline</span> T _max(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b) &#123; <span class="keyword">return</span> (a &gt; b) ? a : b; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sparse_table</span>(T n, T *a) : _n(n), _logn(<span class="built_in">lb</span>(n) + <span class="number">1</span>) &#123;</span><br><span class="line">        _table = <span class="keyword">new</span> T *[_n + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n + <span class="number">5</span>; ++i) _table[i] = <span class="keyword">new</span> T[_logn + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _n; ++i) _table[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= _logn; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">                _table[i][j] =</span><br><span class="line">                    _max(_table[i][j - <span class="number">1</span>], _table[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sparse_table</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n + <span class="number">5</span>; ++i) <span class="keyword">delete</span>[] _table[i];</span><br><span class="line">        <span class="keyword">delete</span>[] _table;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">query</span><span class="params">(T l, T r)</span> </span>&#123;</span><br><span class="line">        T s = <span class="built_in">lb</span>(r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> _max(_table[l][s], _table[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>区间最值, RMQ</tag>
        <tag>稀疏表, ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/52567/</url>
    <content><![CDATA[<p>玄学哈希。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://oi-wiki.org/string/hash/">OI Wiki</a></p>
<p>在比较字符串时我们一般一个一个字符进行比较，对于长度为 $m$ 和 $n$ 的字符串，比较两者的时间复杂度为 $\Theta(max\{m, n\})$ ，但是每次比较都是这个时间复杂度，于是我们希望有 $\Theta(n)$ 预处理， $\Theta(1)$ 比较的方法，这个方法就是字符串哈希。</p>
<p>字符串哈希，就是将一个字符串映射成一个整数，这样我们就可以直接用映射后的整数进行 $\Theta(1)$ 的比较。</p>
<p>那么如何设计哈希函数呢？有很多方法，最常用的是“BKDR Hash”算法。</p>
<h2 id="BKDR-Hash"><a href="#BKDR-Hash" class="headerlink" title="BKDR Hash"></a>BKDR Hash</h2><p>这个算法将字符串当作一个 $P$ 进制数，每个字符再映射到一个数（通常是 $a<del>z$ 映射到 $1</del>26$ 然后计算出这个字符串在 $P$ 进制下模 $M$ 的值，即这个字符串的哈希值，通常选取 $131$ 或 $13331$ 作为模数，这样冲突概率比较小，这样一次哈希的叫做单（模数）哈希，通过使用两次模数不同的哈希可以更加精确降低错误率。</p>
<p>为了简单，模数一般选 $2^{64}$ ，直接用 <code>unsigned long long</code> 储存，省去了极慢的取模运算。</p>
<h1 id="color-Green-code"><a href="#color-Green-code" class="headerlink" title="$\color{Green}code$"></a>$\color{Green}code$</h1><h2 id="OI"><a href="#OI" class="headerlink" title="$OI$"></a>$OI$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="function">ull <span class="title">bkdr_hash</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        ans = ans * base +(ull) s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>【模板】字符串哈希 提交地址：<a href="https://www.luogu.com.cn/problem/P3370">洛谷 Luogu3370【模板】字符串哈希</a></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>哈希, HASH</tag>
      </tags>
  </entry>
  <entry>
    <title>伸展树, Splay</title>
    <url>/57120/</url>
    <content><![CDATA[<p>写完保存怎么突然全乱码了啊……</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91">维基百科</a>，<a href="https://oi-wiki.org/ds/splay/">OI Wiki</a></p>
<p>伸展树并不是严格意义上的平衡树，其核心是通过 $\rm Splay$ 来维护树的平衡。</p>
<p><del>以下代码均来自 <a href="https://lawrencesivan.github.io/">$\rm \color{black}L\color{red}awrenceSivan$</a> 。</del></p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>存数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> son;</span><br><span class="line">&#125; t[maxn];</span><br></pre></td></tr></table></figure>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>插入正负无穷 $\rm INF$ 和 $\rm -INF$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(-INF);</span><br><span class="line"><span class="built_in">insert</span>(INF);</span><br></pre></td></tr></table></figure>

<h2 id="标记更新"><a href="#标记更新" class="headerlink" title="标记更新"></a>标记更新</h2><p>与 $\rm Treap$ 一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].son = t[<span class="built_in">ls</span>(x)].son + t[<span class="built_in">rs</span>(x)].son + t[x].cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p><del>最简单的左右旋。</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = t[x].fa;</span><br><span class="line">    <span class="keyword">int</span> g = t[f].fa;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">rs</span>(f) == x;</span><br><span class="line"></span><br><span class="line">    t[g].ch[<span class="built_in">rs</span>(g) == f] = x;</span><br><span class="line">    t[x].fa = g;</span><br><span class="line"></span><br><span class="line">    t[f].ch[s] = t[x].ch[s ^ <span class="number">1</span>];</span><br><span class="line">    t[t[x].ch[s ^ <span class="number">1</span>]].fa = f;</span><br><span class="line"></span><br><span class="line">    t[x].ch[s ^ <span class="number">1</span>] = f;</span><br><span class="line">    t[f].fa = x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_up</span>(f), <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="伸展"><a href="#伸展" class="headerlink" title="伸展"></a>伸展</h1><p>将节点旋转到根节点，是左儿子就右旋，右儿子就左旋。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (t[x].fa != goal) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = t[x].fa;</span><br><span class="line">        <span class="keyword">int</span> g = t[f].fa;</span><br><span class="line">        <span class="keyword">if</span> (g != goal) &#123;</span><br><span class="line">            (<span class="built_in">ls</span>(f) == x) ^ (<span class="built_in">ls</span>(g) == f) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>插入后需要 $\rm Splay$ 到根节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u &amp;&amp; t[u].val != x) &#123;</span><br><span class="line">        f = u;</span><br><span class="line">        u = t[u].ch[x &gt; t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u)</span><br><span class="line">        t[u].cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (f) t[f].ch[x &gt; t[f].val] = u;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ls</span>(tot) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rs</span>(tot) = <span class="number">0</span>;</span><br><span class="line">        t[tot].fa = f;</span><br><span class="line">        t[tot].val = x;</span><br><span class="line">        t[tot].cnt = <span class="number">1</span>;</span><br><span class="line">        t[tot].son = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找一个节点并旋转到根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) &#123;</span><br><span class="line">        u = t[u].ch[x &gt; t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查前-后驱"><a href="#查前-后驱" class="headerlink" title="查前 / 后驱"></a>查前 / 后驱</h2><p>查找前后驱。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Nxt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> ((t[u].val &gt; x &amp;&amp; f) || (t[u].val &lt; x &amp;&amp; !f)) <span class="keyword">return</span> u;</span><br><span class="line">    u = t[u].ch[f];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t[u].ch[f ^ <span class="number">1</span>]) u = t[u].ch[f ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="built_in">Nxt</span>(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="built_in">Nxt</span>(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Splay</span>(pre, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Splay</span>(nxt, pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> del = <span class="built_in">ls</span>(nxt);</span><br><span class="line">    <span class="keyword">if</span> (t[del].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        t[del].cnt--;</span><br><span class="line">        <span class="built_in">Splay</span>(del, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">ls</span>(nxt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找排名为-x-的数的值"><a href="#查找排名为-x-的数的值" class="headerlink" title="查找排名为 $x$ 的数的值"></a>查找排名为 $x$ 的数的值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> (t[u].son &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">ls</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; t[s].son + t[u].cnt) &#123;</span><br><span class="line">            x -= t[s].son + t[u].cnt;</span><br><span class="line">            u = <span class="built_in">rs</span>(u);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[s].son &gt;= x)</span><br><span class="line">            u = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t[u].val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>由 $\rm Splay$ 操作保证均摊复杂度为 $\Theta(\log n)$ 。</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm \color{Green}code$"></a>$\rm \color{Green}code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) t[(x)].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) t[(x)].ch[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, root, tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> son;</span><br><span class="line">&#125; t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].son = t[<span class="built_in">ls</span>(x)].son + t[<span class="built_in">rs</span>(x)].son + t[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = t[x].fa;</span><br><span class="line">    <span class="keyword">int</span> g = t[f].fa;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">rs</span>(f) == x;</span><br><span class="line"></span><br><span class="line">    t[g].ch[<span class="built_in">rs</span>(g) == f] = x;</span><br><span class="line">    t[x].fa = g;</span><br><span class="line"></span><br><span class="line">    t[f].ch[s] = t[x].ch[s ^ <span class="number">1</span>];</span><br><span class="line">    t[t[x].ch[s ^ <span class="number">1</span>]].fa = f;</span><br><span class="line"></span><br><span class="line">    t[x].ch[s ^ <span class="number">1</span>] = f;</span><br><span class="line">    t[f].fa = x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_up</span>(f), <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (t[x].fa != goal) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = t[x].fa;</span><br><span class="line">        <span class="keyword">int</span> g = t[f].fa;</span><br><span class="line">        <span class="keyword">if</span> (g != goal) &#123;</span><br><span class="line">            (<span class="built_in">ls</span>(f) == x) ^ (<span class="built_in">ls</span>(g) == f) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u &amp;&amp; t[u].val != x) &#123;</span><br><span class="line">        f = u;</span><br><span class="line">        u = t[u].ch[x &gt; t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u)</span><br><span class="line">        t[u].cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (f) t[f].ch[x &gt; t[f].val] = u;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ls</span>(tot) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rs</span>(tot) = <span class="number">0</span>;</span><br><span class="line">        t[tot].fa = f;</span><br><span class="line">        t[tot].val = x;</span><br><span class="line">        t[tot].cnt = <span class="number">1</span>;</span><br><span class="line">        t[tot].son = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (t[u].ch[x &gt; t[u].val] &amp;&amp; x != t[u].val) &#123;</span><br><span class="line">        u = t[u].ch[x &gt; t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Splay</span>(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Nxt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> ((t[u].val &gt; x &amp;&amp; f) || (t[u].val &lt; x &amp;&amp; !f)) <span class="keyword">return</span> u;</span><br><span class="line">    u = t[u].ch[f];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t[u].ch[f ^ <span class="number">1</span>]) u = t[u].ch[f ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="built_in">Nxt</span>(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="built_in">Nxt</span>(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Splay</span>(pre, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Splay</span>(nxt, pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> del = <span class="built_in">ls</span>(nxt);</span><br><span class="line">    <span class="keyword">if</span> (t[del].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        t[del].cnt--;</span><br><span class="line">        <span class="built_in">Splay</span>(del, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">ls</span>(nxt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = root;</span><br><span class="line">    <span class="keyword">if</span> (t[u].son &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">ls</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; t[s].son + t[u].cnt) &#123;</span><br><span class="line">            x -= t[s].son + t[u].cnt;</span><br><span class="line">            u = <span class="built_in">rs</span>(u);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[s].son &gt;= x)</span><br><span class="line">            u = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t[u].val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">insert</span>(-INF);</span><br><span class="line">    <span class="built_in">insert</span>(INF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">Delete</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[<span class="built_in">ls</span>(root)].son);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(x + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[<span class="built_in">Nxt</span>(x, <span class="number">0</span>)].val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[<span class="built_in">Nxt</span>(x, <span class="number">1</span>)].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P3369">洛谷 Luogu3369 【模板】普通平衡树</a></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树, Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-15 杂谈</title>
    <url>/6888/</url>
    <content><![CDATA[<p>今天风沙真大。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-05-22 杂谈</title>
    <url>/23826/</url>
    <content><![CDATA[<p>默哀。</p>
<span id="more"></span>

<p>$$\begin{gathered}\boxed{\begin{matrix}\color{white}\tfrac{}{\tfrac{}{\tfrac{}{\color{black}\begin{gathered}\colorbox{black}{\color{white}\Huge\textbf{R.I.P}}\cr\text{\tiny 2021.5.22 13:07}\cr \footnotesize\texttt{\red{袁隆平} 于长沙逝世}\cr\cr\cr\cr \cr \small\texttt{“杂交水稻之父”、“共和国勋章”}\cr \cr\small\texttt{获得者袁隆平，因多器官功能衰}\cr \cr\small\texttt{竭，于2021年5月22日13时07分}\cr \cr\small\texttt{在长沙逝世，享年91岁。} \cr \cr \cr\scriptsize\text{默哀。} \end{gathered}}}}\end{matrix}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{180pt}}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{230pt}}}\end{gathered}$$ $$\begin{gathered}\boxed{\begin{matrix}\color{white}\tfrac{}{\tfrac{}{\tfrac{}{\color{black}\begin{gathered}\colorbox{black}{\color{white}\Huge\textbf{R.I.P}}\cr\text{\tiny 2021.5.22 13:05}\cr \footnotesize\texttt{\red{吴孟超} 于上海逝世}\cr\cr\cr\cr \cr \small\texttt{中国科学院院士、国家最高科学}\cr \cr\small\texttt{技术奖获得者、“中国肝胆外科}\cr \cr\small\texttt{之父”吴孟超同志，因病医治无}\cr \cr\small\texttt{效，在上海逝世，享年99岁。} \cr \cr \cr\scriptsize\text{默哀。} \end{gathered}}}}\end{matrix}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{180pt}}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{230pt}}}\end{gathered}$$ $$\begin{gathered}\boxed{\begin{matrix}\color{white}\tfrac{}{\tfrac{}{\tfrac{}{\color{black}\begin{gathered}\colorbox{black}{\color{white}\Huge\textbf{R.I.P}}\cr\text{\tiny 2021.5.21 12:40}\cr \footnotesize\texttt{\red{杨伯达} 于北京逝世}\cr\cr\cr\cr \cr \small\texttt{据故宫博物院消息，故宫博物院}\cr \cr\small\texttt{原副院长、文博专家杨伯达先生,}\cr \cr\small\texttt{不幸于2021年5月21日12时40分}\cr \cr\small\texttt{在北京去世，享年94岁。} \cr \cr \cr\scriptsize\text{默哀。} \end{gathered}}}}\end{matrix}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{180pt}}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{230pt}}}\end{gathered}$$ $$\begin{gathered}\boxed{\begin{matrix}\color{white}\tfrac{}{\tfrac{}{\tfrac{}{\color{black}\begin{gathered}\colorbox{black}{\color{white}\Huge\textbf{R.I.P}}\cr\text{\tiny 2021.5.20 16:28}\cr \footnotesize\texttt{\red{夏德昭} 于沈阳仙逝}\cr\cr\cr\cr \cr \small\texttt{中国著名眼科学专家、医学教育}\cr \cr\small\texttt{家夏德昭同志，于2021年5月20}\cr \cr\small\texttt{日16时28分在沈阳仙逝，享年1}\cr \cr\small\texttt{04岁。} \cr \cr \cr\scriptsize\text{默哀。} \end{gathered}}}}\end{matrix}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{180pt}}} \cr\fcolorbox{black}{grey}{\raisebox{12pt}{\kern{230pt}}}\end{gathered}$$</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>讣告</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-10 杂谈</title>
    <url>/9512/</url>
    <content><![CDATA[<p>今天 $UNOI$ 开始了。</p>
<span id="more"></span>

<p>今天突然知道<a href="https://zh.wikipedia.org/wiki/%E7%88%B1%E4%B8%81%E5%A0%A1%E5%85%AC%E7%88%B5%E8%8F%B2%E5%88%A9%E6%99%AE%E4%BA%B2%E7%8E%8B">菲利普亲王</a>去世了，经历过二战的人还活着的不多了</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-06-02 杂谈</title>
    <url>/54447/</url>
    <content><![CDATA[<p>$\rm Karry5307$ 被踢出 HN 省队了。</p>
<span id="more"></span>

<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://www.noi.cn/gs/xw/hn12/2021-06-02/726651.shtml">CCF-NOI NOI2021湖南省选结果公布</a></p>
<p><a href="https://www.zhihu.com/question/360640895/answer/1876835710">知乎 如何评价湖南 OIer Karry5307？</a></p>
<p><a href="https://www.luogu.com.cn/blog/my-vegetable-died/ssH-iN-OI">洛谷日报 #340 [OwO]SSH的在算法竞赛中的妙用 (已撤回）</a></p>
<p><a href="https://www.luogu.com.cn/blog/my-vegetable-died/how-to-shengxuan-over-300">此篇日报已被删除</a></p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-06-08 杂谈</title>
    <url>/43823/</url>
    <content><![CDATA[<p>听了一晚上（？）计数，头疼。<span id="more"></span>刚刚洛谷日爆……，头疼死了，明天和二北考试。</p>
<p>明天高考要结束了……</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-04-03 杂谈</title>
    <url>/41061/</url>
    <content><![CDATA[<p>呵呵。</p>
<span id="more"></span>

<p>马上信息技术学业水平考试，班里一群对 $\rm Python$ 一无所知的人， $\rm MS\ Office$ 也不会用，还在玩扫雷，挂科警告！！！</p>
<p>结果 <a href="https://nonfriedchips.github.io/">$\rm \color{red}w\color{black}iki$($\rm non\_fried\_chips$)</a> 挂了 B 。</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-06-09 杂谈</title>
    <url>/26606/</url>
    <content><![CDATA[<p>高考结束了。<p>
<span id="more"></span>
<p><time>18:15</time>新全国一卷最后一场考试化学收卷，高考结束。</p>
<p>结束亦是开始。</p>
<hr>
<iframe style="width: 100%; height: 424.5px" src="https://www.luogu.org/"></iframe>
<p>似曾相识？</p>
<iframe style="width: 100%; height: 482.5px" src="https://www.google.cn/"></iframe>
<p>emmmm</p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>2021-06-28 杂谈 记一只小傻虫</title>
    <url>/47150/</url>
    <content><![CDATA[<p>今天， 2021 年 6 月 28 日。</p>
<p>笃行楼 5 楼 3 机房，没有缝的窗户中，钻进了一只虫。</p>
<span id="more"></span>

<p>这只虫比较粗胖，黑翅黑身，又圆又扁。</p>
<p>进来就到处乱撞，半天打不下来。</p>
<p>照片：链接：<a href="https://pan.baidu.com/s/16hf5AxOC09KEHOeZ4_r2sA">https://pan.baidu.com/s/16hf5AxOC09KEHOeZ4_r2sA</a> 提取码：rncb</p>
<p>傻死了，她要么一直撞灯，要么一直绕机房飞，杰哥拿着扫帚打了半天也打不下来。</p>
<hr>
<p>过了一会儿又到一个灯的链子上了，但我们要怎么把她从灯上打下来啊？</p>
<p>天啊，她怎么一直在撞灯，真的装不傻吗。</p>
<p>放张照片：</p>
<p><img src="BUG.png" alt="BUG"></p>
<hr>
<p>6 月 28 日</p>
<p>杰哥上去打她，结果把灯打下来了。</p>
<p><img src="hit-light.jpg" alt="hit light"></p>
<p>大家都在哈哈笑。</p>
<hr>
<p>已经被杰哥打死了，估计是没了</p>
<p><img src="kk.png" alt="/kk"></p>
<p><img src="kl.png" alt="/kl"></p>
<hr>
<p>上面开个玩笑哈 <del><a href="https://renamoe.gitee.io/">$\rm\color{black}{R}\color{red}{enaMoe}$ </a>别打人</del>。</p>
<p>今天 $\rm rainnn$ 突然大叫了一声，然后发现一直不知道是啥的虫子飞了进来，然后到处撞灯撞墙，然后杰哥一直打打不到。过了一会飞到了灯上，然后杰哥想把虫子打下来，结果把灯打下来了。</p>
<p>然后又飞了半天到处撞，最后还是被打下来了，整个机房都在笑。</p>
<p>（$\rm \color{black}w\color{red}iki$($\rm non\_fried\_chips$)：我笑得肚子疼。）</p>
<p>（$\rm \color{black}L\color{red}awrenceSivan$：隔壁省队的队爷们不会认为隔壁疯了吧？）</p>
<p>附几张照片：</p>
<p><img src="WIN_20210628_19_49_33_Pro.jpg" alt="WIN_20210628_19_49_33_Pro"></p>
<p><img src="WIN_20210628_19_49_46_Pro.jpg" alt="WIN_20210628_19_49_46_Pro"></p>
<p><img src="WIN_20210628_19_50_00_Pro_LI.jpg" alt="WIN_20210628_19_50_00_Pro_LI"></p>
<p><img src="WIN_20210628_19_50_12_Pro_LI.jpg" alt="WIN_20210628_19_50_12_Pro_LI"></p>
<p><img src="WIN_20210628_19_50_32_Pro_LI.jpg" alt="WIN_20210628_19_50_32_Pro_LI"></p>
]]></content>
      <categories>
        <category>日志</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>机房</tag>
        <tag>虫子, BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/37773/</url>
    <content><![CDATA[<p>本博客已上线。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>日志</category>
        <category>维护</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>树堆, Treap</title>
    <url>/15981/</url>
    <content><![CDATA[<p>最简单的平衡树了。</p>
<span id="more"></span>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>百科：<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E5%A0%86">维基百科</a>，<a href="https://oi-wiki.org/ds/treap/">OI Wiki</a></p>
<p>什么是 $\rm Treap$ ？</p>
<p>$\rm Treap$ 这个词是由 $\rm Tree$ 和 $\rm Heap$ 组合而来的，表明它既有堆的性质，也有二叉搜索树的性质，它可以支持查询排名等操作。</p>
<p>$\rm Treap$ 每个节点多维护一个优先级 $\rm priority$ ，父节点的优先级需要大于子节点，而优先级是随机生成的，所以 $\rm Treap$ 是期望平衡的。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>一个结构体，我使用指针来存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    node* son[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> value) : <span class="built_in">key</span>(value), <span class="built_in">rank</span>(<span class="built_in">rand</span>()), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">size</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        son[<span class="number">0</span>] = son[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        size = cnt + (son[<span class="number">0</span>] ? son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (son[<span class="number">1</span>] ? son[<span class="number">1</span>]-&gt;size : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; a, <span class="keyword">const</span> node&amp; b) &#123; <span class="keyword">return</span> a.rank &lt; b.rank; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p><code>key</code> ：节点值；</p>
<p><code>rank</code> ：优先级；</p>
<p><code>cnt</code> ：该值有几个；</p>
<p><code>size</code> ：子树大小（ <code>cnt</code> 加权）。</p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><code>node(int valuse)</code> ：构造函数，并随机一个优先级。</p>
<p><code>inline void update(void)</code> ：更新节点值。</p>
<h2 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h2><p><code>inline bool operator&lt;(const node&amp; a, const node&amp; b)</code> ：用于比较优先级。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p><del>$\rm Treap$ 不需要建树。</del></p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>最简单的左右旋，只要子节点优先级比父节点大，就旋转上去。</p>
<p><code>zig</code> 为右旋， <code>zag</code> 为左旋。</p>
<p>原图：</p>
<p><img src="./back.png" alt="back"></p>
<p>将原图右旋：</p>
<p><img src="./zig.png" alt="zig"></p>
<p>将原图左旋：</p>
<p><img src="zag.png" alt="zag"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(node*&amp; p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    node* t = p-&gt;son[d ^ <span class="number">1</span>];</span><br><span class="line">    p-&gt;son[d ^ <span class="number">1</span>] = t-&gt;son[d];</span><br><span class="line">    t-&gt;son[d] = p;</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">    t-&gt;<span class="built_in">update</span>();</span><br><span class="line">    p = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入一个节点并通过旋转来调整树的结构使其满足堆的性质。</p>
<p>由于值是可重复的，所以如果已经有了这个值，则 <code>cnt++</code> ，否则根据当前点的键值大小决定向左或右插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node*&amp; p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">node</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key == k)</span><br><span class="line">        p-&gt;cnt++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &gt; k)</span><br><span class="line">            <span class="built_in">insert</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>] &amp;&amp; *p &lt; *p-&gt;son[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">1</span>] &amp;&amp; *p &lt; *p-&gt;son[<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除一个值，但由于值是可重复的，先 <code>cnt--</code> 直到 $0$ ，然后再删节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(node*&amp; p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key == k)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;cnt &gt; <span class="number">1</span>)</span><br><span class="line">            p-&gt;cnt--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(p-&gt;son[<span class="number">0</span>] || p-&gt;son[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>] &amp;&amp; p-&gt;son[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> (*p-&gt;son[<span class="number">0</span>] &lt; *p-&gt;son[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)</span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找值为-k-的数的排名（排名定义为比当前数小的数的个数-1-）"><a href="#查找值为-k-的数的排名（排名定义为比当前数小的数的个数-1-）" class="headerlink" title="查找值为 $k$ 的数的排名（排名定义为比当前数小的数的个数 $ + 1$ ）"></a>查找值为 $k$ 的数的排名（排名定义为比当前数小的数的个数 $ + 1$ ）</h2><p>左右找就行，和普通的二叉搜索树一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_kth</span><span class="params">(node* p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_kth</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + p-&gt;cnt +</span><br><span class="line">               <span class="built_in">find_kth</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找排名为-k-的数的值"><a href="#查找排名为-k-的数的值" class="headerlink" title="查找排名为 $k$ 的数的值"></a>查找排名为 $k$ 的数的值</h2><p>通过与子树大小比较来找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_value</span><span class="params">(node* p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; r &amp;&amp; r &lt;= s + p-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_value</span>(p-&gt;son[<span class="number">0</span>], r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_value</span>(p-&gt;son[<span class="number">1</span>], r - s - p-&gt;cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求-x-的前驱（前驱定义为小于-x-，且最大的数）"><a href="#求-x-的前驱（前驱定义为小于-x-，且最大的数）" class="headerlink" title="求 $x$ 的前驱（前驱定义为小于 $x$ ，且最大的数）"></a>求 $x$ 的前驱（前驱定义为小于 $x$ ，且最大的数）</h2><p>和普通的二叉搜索树一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_pre</span><span class="params">(node* p, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &gt; ans) ans = p-&gt;key;</span><br><span class="line">        <span class="built_in">get_pre</span>(p-&gt;son[<span class="number">1</span>], k, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">get_pre</span>(p-&gt;son[<span class="number">0</span>], k, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求-x-的后继（后继定义为小于-x-，且最小的数）"><a href="#求-x-的后继（后继定义为小于-x-，且最小的数）" class="headerlink" title="求 $x$ 的后继（后继定义为小于 $x$ ，且最小的数）"></a>求 $x$ 的后继（后继定义为小于 $x$ ，且最小的数）</h2><p>还是和普通的二叉搜索树一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">(node* p, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &lt; ans) ans = p-&gt;key;</span><br><span class="line">        <span class="built_in">get_nxt</span>(p-&gt;son[<span class="number">0</span>], k, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">get_nxt</span>(p-&gt;son[<span class="number">1</span>], k, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>由于是随机权值，期望复杂度为 $\Theta(n \log n)$ 。</p>
<h1 id="rm-color-Green-code"><a href="#rm-color-Green-code" class="headerlink" title="$\rm \color{Green} code$"></a>$\rm \color{Green} code$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qread</span><span class="params">(T&amp; n)</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) n = (n &lt;&lt; <span class="number">3</span>) + (n &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (flag) n = (~n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    node* son[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> value) : <span class="built_in">key</span>(value), <span class="built_in">rank</span>(<span class="built_in">rand</span>()), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">size</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        son[<span class="number">0</span>] = son[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        size = cnt + (son[<span class="number">0</span>] ? son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (son[<span class="number">1</span>] ? son[<span class="number">1</span>]-&gt;size : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; * root;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; a, <span class="keyword">const</span> node&amp; b) &#123; <span class="keyword">return</span> a.rank &lt; b.rank; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(node*&amp; p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    node* t = p-&gt;son[d ^ <span class="number">1</span>];</span><br><span class="line">    p-&gt;son[d ^ <span class="number">1</span>] = t-&gt;son[d];</span><br><span class="line">    t-&gt;son[d] = p;</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">    t-&gt;<span class="built_in">update</span>();</span><br><span class="line">    p = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node*&amp; p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">node</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;key == k)</span><br><span class="line">        p-&gt;cnt++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &gt; k)</span><br><span class="line">            <span class="built_in">insert</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>] &amp;&amp; *p &lt; *p-&gt;son[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">1</span>] &amp;&amp; *p &lt; *p-&gt;son[<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(node*&amp; p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key == k)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;cnt &gt; <span class="number">1</span>)</span><br><span class="line">            p-&gt;cnt--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(p-&gt;son[<span class="number">0</span>] || p-&gt;son[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>] &amp;&amp; p-&gt;son[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> (*p-&gt;son[<span class="number">0</span>] &lt; *p-&gt;son[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;son[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(p, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)</span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_kth</span><span class="params">(node* p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_kth</span>(p-&gt;son[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + p-&gt;cnt +</span><br><span class="line">               <span class="built_in">find_kth</span>(p-&gt;son[<span class="number">1</span>], k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_value</span><span class="params">(node* p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = p-&gt;son[<span class="number">0</span>] ? p-&gt;son[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; r &amp;&amp; r &lt;= s + p-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_value</span>(p-&gt;son[<span class="number">0</span>], r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_value</span>(p-&gt;son[<span class="number">1</span>], r - s - p-&gt;cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_pre</span><span class="params">(node* p, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &gt; ans) ans = p-&gt;key;</span><br><span class="line">        <span class="built_in">get_pre</span>(p-&gt;son[<span class="number">1</span>], k, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">get_pre</span>(p-&gt;son[<span class="number">0</span>], k, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">(node* p, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;key &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key &lt; ans) ans = p-&gt;key;</span><br><span class="line">        <span class="built_in">get_nxt</span>(p-&gt;son[<span class="number">0</span>], k, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">get_nxt</span>(p-&gt;son[<span class="number">1</span>], k, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, op, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">qread</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">qread</span>(op), <span class="built_in">qread</span>(x);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">insert</span>(root, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">remove</span>(root, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find_kth</span>(root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find_value</span>(root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: &#123;</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">                <span class="built_in">get_pre</span>(root, x, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: &#123;</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">                <span class="built_in">get_nxt</span>(root, x, ans);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P3369">洛谷 Luogu3369 【模板】普通平衡树</a></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>随机化</tag>
        <tag>堆</tag>
        <tag>树堆, Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-04-03 更新</title>
    <url>/22936/</url>
    <content><![CDATA[<p>Valine 评论功能已开启。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>日志</category>
        <category>维护</category>
      </categories>
  </entry>
  <entry>
    <title>vim 配置</title>
    <url>/34166/</url>
    <content><![CDATA[<p>本人的 vim 配置，比较好背，用起来还不错，适合考场。</p>
<span id="more"></span>

<h1 id="rm-vim-配置"><a href="#rm-vim-配置" class="headerlink" title="$\rm vim$ 配置"></a>$\rm vim$ 配置</h1><p>在终端中使用 $\rm vim$ 打开配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>按 <code>i</code> 进入插入模式，输入以下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set nu</span><br><span class="line">set ru</span><br><span class="line">set mouse=a</span><br><span class="line">set tabstop=4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set backspace=2</span><br><span class="line">set expandtab</span><br><span class="line">set showmatch</span><br><span class="line">set matchtime=5</span><br><span class="line">set cindent</span><br><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line">set nocompatible</span><br><span class="line">set showmode</span><br><span class="line">set showcmd</span><br><span class="line">colorscheme blue</span><br><span class="line">inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line">inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">inoremap [ []&lt;ESC&gt;i</span><br><span class="line">inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;kA</span><br><span class="line">syntax on</span><br><span class="line">map &lt;F5&gt; :call CompileRun()&lt;CR&gt;</span><br><span class="line">func! CompileRun()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &#x27;c&#x27;</span><br><span class="line">        exec &quot;!gcc \&quot;%\&quot; -lm -Wall -Wextra -o \&quot;%&lt;\&quot; &amp;&amp; ./\&quot;%&lt;\&quot; &amp;&amp; cat \&quot;%&lt;.out\&quot; | less&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;cpp&#x27;</span><br><span class="line">        exec &quot;!g++ \&quot;%\&quot; -lm -Wall -Wextra -o \&quot;%&lt;\&quot; &amp;&amp; ./\&quot;%&lt;\&quot; &amp;&amp; cat \&quot;%&lt;.out\&quot; | less&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;sh&#x27;</span><br><span class="line">        exec &quot;!chmod u+x \&quot;%\&quot;&quot;</span><br><span class="line">        exec &quot;! ./\&quot;%\&quot;&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">map &lt;F6&gt; :call CompileRunLOCAL()&lt;CR&gt;</span><br><span class="line">func! CompileRunLOCAL()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &#x27;c&#x27;</span><br><span class="line">        exec &quot;!gcc \&quot;%\&quot; -lm -g -Wall -Wextra -DLOCAL -o \&quot;%&lt;\&quot; &amp;&amp; ./\&quot;%&lt;\&quot;&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;cpp&#x27;</span><br><span class="line">        exec &quot;!g++ \&quot;%\&quot; -lm -g -Wall -Wextra -DLOCAL -o \&quot;%&lt;\&quot; &amp;&amp; ./\&quot;%&lt;\&quot;&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;sh&#x27;</span><br><span class="line">        exec &quot;!chmod u+x \&quot;%\&quot;&quot;</span><br><span class="line">        exec &quot;! ./\&quot;%\&quot;&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>

<p><code>&lt;ESC&gt;:wq</code> 以保存。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-03-22 更新</title>
    <url>/33114/</url>
    <content><![CDATA[<p>Gitalk 评论功能已开启。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>日志</category>
        <category>维护</category>
      </categories>
  </entry>
</search>
